{"meta":{"title":"夤夜的世界旅行手记","subtitle":"你好，陌生人。","description":"某211软工专业在读","author":"Shinya","url":"https://shinya754.github.io","root":"/"},"pages":[{"title":"力扣82. 删除排序链表中的重复元素II","date":"2021-03-25T14:14:42.000Z","updated":"2021-06-01T03:52:07.169Z","comments":true,"path":"Deleted_Posts/2021-03-25-力扣82-删除排序链表中的重复元素II.html","permalink":"https://shinya754.github.io/Deleted_Posts/2021-03-25-%E5%8A%9B%E6%89%A382-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II.html","excerpt":"2021.3.25 82. 删除排序链表中的重复元素IIhttps://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/ 存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 没有重复出现 的数字。 返回同样按升序排列的结果链表。","text":"2021.3.25 82. 删除排序链表中的重复元素IIhttps://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/ 存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 没有重复出现 的数字。 返回同样按升序排列的结果链表。 示例 1： 输入：head &#x3D; [1,2,3,3,4,4,5] 输出：[1,2,5] 示例 2： 输入：head &#x3D; [1,1,1,2,3] 输出：[2,3] 提示： 链表中节点数目在范围 [0, 300] 内-100 &lt;= Node.val &lt;= 100题目数据保证链表已经按升序排列 &amp;emsp;学到的知识点：emmm不知道有没有&amp;emsp;什么？链表插入删除相关的题目不就一种方法嘛？&amp;emsp;先创建一个relPre节点用于指向head节点（基本操作）&amp;emsp;对于本题，设置一个遍历整个列表一次的指针pointer，每次比较pointer.val是否等于pointer.next.val，如果等于就一直往后找到一个不等元素，再把前面和后面连接起来。 最终代码如下： public class Solution &#123; public ListNode DeleteDuplicates(ListNode head) &#123; ListNode realPre = new ListNode(int.MinValue,head); ListNode pointer = realPre; ListNode pre = realPre; while(pointer!=null &amp;&amp; pointer.next!=null)&#123; if(pointer.val==pointer.next.val)&#123; while(pointer.next!=null&amp;&amp;pointer.val==pointer.next.val)&#123; pointer=pointer.next; &#125; pre.next=pointer.next; pointer=pre; &#125; pre=pointer; pointer=pointer.next; &#125; return realPre.next; &#125; &#125;"},{"title":"力扣83. 删除排序链表中的重复元素","date":"2021-03-26T12:17:35.000Z","updated":"2021-06-01T03:52:20.321Z","comments":true,"path":"Deleted_Posts/2021-03-26-力扣83-删除排序链表中的重复元素.html","permalink":"https://shinya754.github.io/Deleted_Posts/2021-03-26-%E5%8A%9B%E6%89%A383-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0.html","excerpt":"2021.3.26 83. 删除排序链表中的重复元素https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/ 存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次 。 返回同样按升序排列的结果链表。","text":"2021.3.26 83. 删除排序链表中的重复元素https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/ 存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次 。 返回同样按升序排列的结果链表。 示例 1： 输入：head &#x3D; [1,1,2] 输出：[1,2] 示例 2： 输入：head &#x3D; [1,1,2,3,3] 输出：[1,2,3] 提示： 链表中节点数目在范围 [0, 300] 内-100 &lt;&#x3D; Node.val &lt;&#x3D; 100题目数据保证链表已经按升序排列 &amp;emsp;学到的知识点：…？&amp;emsp;刚看到这题：啊这个EZ啊，把昨天的代码改一改… public class Solution &#123; public ListNode DeleteDuplicates(ListNode head) &#123; ListNode realPre = new ListNode(int.MinValue,head); ListNode pointer = realPre; ListNode pre = realPre; while(pointer!=null &amp;&amp; pointer.next!=null)&#123; if(pointer.val==pointer.next.val)&#123; pre = pointer;//加上了这一句 //解释：这一题和昨天那题相比，区别就是对每个存在重复值的节点，保留第一个节点。 while(pointer.next!=null&amp;&amp;pointer.val==pointer.next.val)&#123; pointer=pointer.next; &#125; pre.next=pointer.next; pointer=pre; &#125; pre=pointer; pointer=pointer.next; &#125; return realPre.next; &#125; &#125; 然后发现运行时间比别人的长了那么一点点然后一看难度简单，再一看昨天那题难度中等&amp;emsp;重写如下： public class Solution &#123; public ListNode DeleteDuplicates(ListNode head) &#123; if(head==null)&#123;//喜欢拿空链表恶心人是吧 return head; &#125; ListNode pointer = head; while(pointer.next!=null)&#123; if(pointer.val==pointer.next.val)&#123; pointer.next = pointer.next.next; &#125; else&#123; pointer=pointer.next; &#125; &#125; return head; &#125; &#125; &amp;emsp;（不是，你怎么不用自建头节点啊（恼"},{"title":"力扣190. 颠倒二进制位","date":"2021-03-29T03:13:18.000Z","updated":"2021-06-01T03:53:46.258Z","comments":true,"path":"Deleted_Posts/2021-03-29-力扣190-颠倒二进制位.html","permalink":"https://shinya754.github.io/Deleted_Posts/2021-03-29-%E5%8A%9B%E6%89%A3190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D.html","excerpt":"2021.3.29 190. 颠倒二进制位https://leetcode-cn.com/problems/reverse-bits/颠倒给定的 32 位无符号整数的二进制位。 提示： &amp;emsp;请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。&amp;emsp;在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。 进阶:如果多次调用这个函数，你将如何优化你的算法？","text":"2021.3.29 190. 颠倒二进制位https://leetcode-cn.com/problems/reverse-bits/颠倒给定的 32 位无符号整数的二进制位。 提示： &amp;emsp;请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。&amp;emsp;在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。 进阶:如果多次调用这个函数，你将如何优化你的算法？ 示例 1： 输入: 00000010100101000001111010011100 输出: 00111001011110000010100101000000 解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596， 因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。 示例 2： 输入：11111111111111111111111111111101 输出：10111111111111111111111111111111 解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293， 因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。 学到的知识点：二进制位运算学过了（问就是一位一位写不是，谁想得到官方题解那个分治法啊（恼代码： class Solution &#123; public: uint32_t reverseBits(uint32_t n) &#123; uint32_t answer=0; for(int i=0;i&lt;32;i++)&#123; uint32_t sign = (n>>i) &amp; 1;//判断从低到高的第i位是否为1 if(sign==1)&#123; answer |= (uint32_t)1&lt;&lt;(31-i); &#125; &#125; return answer; &#125; &#125;; 顺便，Java中有专门用于解决这个问题的函数Integer.reverse(n)，但是Java中并没有无符号整型数（）顺便，Java中这个方法的原码就是用那个分治法写的。"},{"title":"力扣61. 旋转链表","date":"2021-03-27T14:03:41.000Z","updated":"2021-06-01T03:52:50.767Z","comments":true,"path":"Deleted_Posts/2021-03-27-力扣61-旋转链表.html","permalink":"https://shinya754.github.io/Deleted_Posts/2021-03-27-%E5%8A%9B%E6%89%A361-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8.html","excerpt":"2021.3.27 61. 旋转链表https://leetcode-cn.com/problems/rotate-list/给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。","text":"2021.3.27 61. 旋转链表https://leetcode-cn.com/problems/rotate-list/给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。 示例 1： 输入：head &#x3D; [1,2,3,4,5], k &#x3D; 2 输出：[4,5,1,2,3] 示例 2： 输入：head &#x3D; [0,1,2], k &#x3D; 4 输出：[2,0,1] 提示： 链表中节点的数目在范围 [0, 500] 内-100 &lt;= Node.val &lt;= 1000 &lt;= k &lt;= 2 * 109 学到的知识点：链表不就一种方法嘛（什么链表周。 public class Solution &#123; public ListNode RotateRight(ListNode head, int k) &#123; if(head==null||k==0)&#123; return head; &#125; int n=0; ListNode pointer=head; //设置tail指针用于指示尾节点 ListNode tail = head; //先判断链表长度 while(pointer!=null)&#123; n++; tail=pointer; pointer=pointer.next; &#125; k%=n; if(k%n==0)&#123; return head; &#125; //pointer用于找到断开位置的前一个节点 pointer=head; for(int i=0;i&lt;n-k-1;i++)&#123; pointer=pointer.next; &#125; ListNode realHead=pointer.next; pointer.next=null; tail.next=head; return realHead; &#125; &#125;"},{"title":"archives","date":"2021-05-07T11:21:31.000Z","updated":"2021-05-07T11:23:27.512Z","comments":true,"path":"archives/index.html","permalink":"https://shinya754.github.io/archives/index.html","excerpt":"","text":""},{"title":"Hello World","date":"2023-03-21T09:34:48.131Z","updated":"2021-03-23T04:10:00.490Z","comments":true,"path":"Deleted_Posts/hello-world.html","permalink":"https://shinya754.github.io/Deleted_Posts/hello-world.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment"},{"title":"力扣1143. 最长公共子序列","date":"2021-04-03T11:43:38.000Z","updated":"2021-06-01T03:58:27.894Z","comments":true,"path":"Deleted_Posts/2021-04-03-力扣1143-最长公共子序列.html","permalink":"https://shinya754.github.io/Deleted_Posts/2021-04-03-%E5%8A%9B%E6%89%A31143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.html","excerpt":"2021.4.3 1143. 最长公共子序列https://leetcode-cn.com/problems/longest-common-subsequence/给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。 例如，&quot;ace&quot; 是 &quot;abcde&quot; 的子序列，但 &quot;aec&quot; 不是 &quot;abcde&quot; 的子序列。两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。","text":"2021.4.3 1143. 最长公共子序列https://leetcode-cn.com/problems/longest-common-subsequence/给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。 例如，&quot;ace&quot; 是 &quot;abcde&quot; 的子序列，但 &quot;aec&quot; 不是 &quot;abcde&quot; 的子序列。两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。 示例 1： 输入：text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot; 输出：3 解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。 示例 2： 输入：text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;abc&quot; 输出：3 解释：最长公共子序列是 &quot;abc&quot; ，它的长度为 3 。 示例 3： 输入：text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;def&quot; 输出：0 解释：两个字符串没有公共子序列，返回 0 。 学到的知识点：动态规划鬼鬼，这周四才在算法课上学过。最终代码：（C++） class Solution &#123; public: int longestCommonSubsequence(string text1, string text2) &#123; vector&lt;vector&lt;int>> dpVec(text1.size() + 1, vector&lt;int>(text2.size() + 1, 0));//下标1代表text1，下标2代表text2//你们C++怎么不支持动态数组啊（恼 //i=0和j=0对应的数字全是0，即text1和text2在不提供字符时，公共子序列为0 for (int i = 1; i &lt; text1.size() + 1; i++) &#123; for (int j = 1; j &lt; text2.size() + 1; j++) &#123; //如果text1[i-1]和text2[j-1]相等，则取左上角的值+1 if (text1[i - 1] == text2[j - 1]) &#123; dpVec[i][j] = dpVec[i - 1][j - 1] + 1; &#125; //不相等则取上面和左边的值中较大的一个 else &#123; dpVec[i][j] = max(dpVec[i][j - 1], dpVec[i - 1][j]); &#125; &#125; &#125; return dpVec[text1.size()][text2.size()]; &#125; &#125;; 还看到一个用递归的，感觉很机智就记录一下： class Solution: def longestCommonSubsequence(self, t1: str, t2: str) -> int: @lru_cache(None) def dfs(i, j): if not i or not j: return 0 if t1[i-1] == t2[j-1]: return dfs(i-1, j-1) + 1 return max(dfs(i-1,j), dfs(i, j-1)) return dfs(len(t1), len(t2)) //作者：力扣@smile"},{"title":"categories","date":"2021-05-10T12:01:10.000Z","updated":"2021-05-10T12:01:31.185Z","comments":true,"path":"categories/index.html","permalink":"https://shinya754.github.io/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2021-05-10T12:16:11.000Z","updated":"2023-06-14T13:32:24.655Z","comments":true,"path":"links/index.html","permalink":"https://shinya754.github.io/links/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-05-10T11:55:55.000Z","updated":"2021-05-10T12:00:02.962Z","comments":true,"path":"tags/index.html","permalink":"https://shinya754.github.io/tags/index.html","excerpt":"","text":""},{"title":"关于我","date":"2021-05-10T12:03:56.000Z","updated":"2021-05-18T05:08:40.072Z","comments":true,"path":"about/index.html","permalink":"https://shinya754.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"力扣2312-卖木头块","slug":"力扣2312-卖木头块","date":"2024-03-15T02:18:38.000Z","updated":"2024-03-15T03:38:04.531Z","comments":true,"path":"2024/03/15/力扣2312-卖木头块/","link":"","permalink":"https://shinya754.github.io/2024/03/15/%E5%8A%9B%E6%89%A32312-%E5%8D%96%E6%9C%A8%E5%A4%B4%E5%9D%97/","excerpt":"2024.03.15 2312.卖木头块https://leetcode.cn/problems/selling-pieces-of-wood/ 给你两个整数 m 和 n ，分别表示一块矩形木块的高和宽。同时给你一个二维整数数组 prices ，其中 prices[i] = [hi, wi, price[i]] 表示你可以以 price[i] 元的价格卖一块高为 hi 宽为 wi 的矩形木块。 每一次操作中，你必须按下述方式之一执行切割操作，以得到两块更小的矩形木块： 沿垂直方向按高度 完全 切割木块，或沿水平方向按宽度 完全 切割木块在将一块木块切成若干小木块后，你可以根据 prices 卖木块。你可以卖多块同样尺寸的木块。你不需要将所有小木块都卖出去。你 不能 旋转切好后木块的高和宽。 请你返回切割一块大小为 m x n 的木块后，能得到的 最多 钱数。 注意你可以切割木块任意次。","text":"2024.03.15 2312.卖木头块https://leetcode.cn/problems/selling-pieces-of-wood/ 给你两个整数 m 和 n ，分别表示一块矩形木块的高和宽。同时给你一个二维整数数组 prices ，其中 prices[i] = [hi, wi, price[i]] 表示你可以以 price[i] 元的价格卖一块高为 hi 宽为 wi 的矩形木块。 每一次操作中，你必须按下述方式之一执行切割操作，以得到两块更小的矩形木块： 沿垂直方向按高度 完全 切割木块，或沿水平方向按宽度 完全 切割木块在将一块木块切成若干小木块后，你可以根据 prices 卖木块。你可以卖多块同样尺寸的木块。你不需要将所有小木块都卖出去。你 不能 旋转切好后木块的高和宽。 请你返回切割一块大小为 m x n 的木块后，能得到的 最多 钱数。 注意你可以切割木块任意次。 提示： 1 &lt;= m, n &lt;= 2001 &lt;= prices.length &lt;= 2 * 104prices[i].length == 31 &lt;= hi &lt;= m1 &lt;= wi &lt;= n1 &lt;= pricei &lt;= 106所有 (hi, wi) 互不相同 。 &amp;emsp;01背包问题plus。&amp;emsp;虽然看到题目的第一眼就知道是用动态规划，但是在思考状态转移方程的时候思维僵化了，固执地认为dp[i][j]的值一定要通过dp[i][j-1]的值计算。看了提示以后发现，不应该从木块大小的角度思考问题，应该从木块切割方式的角度来思考。&amp;emsp;换句话说即是从木块拼接方式的角度来思考。&amp;emsp;对于一块m*n的木块，其可以直接整块卖出，或者切割一次，卖出比如说大小为m1*n和m2*n的两块木块，价格取最大者即可，而小木块又可以继续像这样再分割。&amp;emsp;因此动态规划的状态转移方程应该是，对位置m,n，取其单独卖出和切割一次卖出的最大价格，而切割一次卖出的最大价格即是遍历切割方式，取价格最高的两个小块的和。&amp;emsp;不过官方题解里面用的哈希我这里省略掉了。 &amp;emsp;代码：（java） class Solution &#123; public long sellingWood(int m, int n, int[][] prices) &#123; long[][] dp = new long[m][n]; for(int i=0;i&lt;prices.length;i++)&#123; int m_ = prices[i][0]; int n_ = prices[i][1]; int pr = prices[i][2]; dp[m_-1][n_-1] = pr; &#125; // 为dp数组赋初始值，即初始价格 for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; dp[i][j] = Math.max(calculate_m_n_price(i,j,dp), dp[i][j]); &#125; &#125; return dp[m-1][n-1]; &#125; private long calculate_m_n_price(int m, int n, long[][] dp)&#123; // 先按列切割，即竖着切 int a=0; int b=n-1; long max_price = 0; while(a&lt;=b)&#123; long temp_price = dp[m][a] + dp[m][b]; max_price = Math.max(max_price, temp_price); a+=1; b-=1; &#125; // 然后按行切割，即横着切 a=0; b=m-1; while(a&lt;=b)&#123; long temp_price = dp[a][n] + dp[b][n]; max_price = Math.max(max_price, temp_price); a+=1; b-=1; &#125; return max_price; &#125; &#125; &amp;emsp;时间复杂度：O(mn(m+n)+p)，其中 p 是数组 prices 的长度。&amp;emsp;空间复杂度：O(mn)，即为动态规划的数组需要使用的空间。","categories":[{"name":"力扣做题笔记","slug":"力扣做题笔记","permalink":"https://shinya754.github.io/categories/%E5%8A%9B%E6%89%A3%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://shinya754.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"力扣","slug":"力扣","permalink":"https://shinya754.github.io/tags/%E5%8A%9B%E6%89%A3/"},{"name":"动态规划","slug":"动态规划","permalink":"https://shinya754.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"Java","slug":"Java","permalink":"https://shinya754.github.io/tags/Java/"}]},{"title":"Windows 11 安装 pytorch3d可能遇到的问题，以及最终成功安装使用的版本分享（使用RTX3070）","slug":"Windows-11-安装-pytorch3d可能遇到的问题，以及最终成功安装使用的版本分享（使用RTX3070）","date":"2023-08-29T14:06:27.000Z","updated":"2023-08-29T14:09:49.243Z","comments":true,"path":"2023/08/29/Windows-11-安装-pytorch3d可能遇到的问题，以及最终成功安装使用的版本分享（使用RTX3070）/","link":"","permalink":"https://shinya754.github.io/2023/08/29/Windows-11-%E5%AE%89%E8%A3%85-pytorch3d%E5%8F%AF%E8%83%BD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%9C%80%E7%BB%88%E6%88%90%E5%8A%9F%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E7%9A%84%E7%89%88%E6%9C%AC%E5%88%86%E4%BA%AB%EF%BC%88%E4%BD%BF%E7%94%A8RTX3070%EF%BC%89/","excerpt":"基础教程参考Win10下pytorch3D安装方法","text":"基础教程参考Win10下pytorch3D安装方法 &amp;emsp;&amp;emsp;由于pytorch3d对于pytorch、CUDA、CUB的版本对应是在是过于严苛，所以我的建议是直接找别人成功安装的软件版本列表对着抄，pytorch啥的该重装重装，反正可以用虚拟环境，CUDA也是，一台电脑共存两个版本的CUDA也不是不行。唯一麻烦一点的可能就是GPU型号太新而找不到能用的CUDA版本，不过好在我这3070还能够用CUDA11.1。&amp;emsp;&amp;emsp;我使用的软硬件版本如下（完全就是对着参考的那篇博客抄的）： GPU：RTX 3070 CUDA：11.1 python：3.8 pytorch：1.9.0 pytorch3d：0.7.1 NVIDIA CUB：cub-1.9.10-1 安装过程中遇到的问题问题1： “C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.2\\bin\\nvcc” -c E:\\Anaconda\\envs\\torch3Dtorch180\\Lib\\site-packages\\pytorch3d-0.6.0\\pytorch3d\\csrc\\ball_query\\ball_query.cu -o build\\temp.win-amd64-cpython-39\\Release\\Anaconda\\envs\\torch3Dtorch180\\Lib\\site-packages\\pytorch3d-0.6.0\\pytorch3d\\csrc\\ball_query\\ball_query.obj -IE:\\Anaconda\\envs\\torch3Dtorch180\\Lib\\site-packages\\pytorch3d-0.6.0\\pytorch3d\\csrc -IE:\\cub-1.9.10-1 -IE:\\Anaconda\\envs\\torch3Dtorch180\\lib\\site-packages\\torch\\include -IE:\\Anaconda\\envs\\torch3Dtorch180\\lib\\site-packages\\torch\\include\\torch\\csrc\\api\\include -IE:\\Anaconda\\envs\\torch3Dtorch180\\lib\\site-packages\\torch\\include\\TH -IE:\\Anaconda\\envs\\torch3Dtorch180\\lib\\site-packages\\torch\\include\\THC “-IC:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.2\\include” -IE:\\Anaconda\\envs\\torch3Dtorch180\\include -IE:\\Anaconda\\envs\\torch3Dtorch180\\Include “-IE:\\Microsoft Visual Studio\\VC\\Tools\\MSVC\\14.29.30133\\include” -Xcudafe –diag_suppress&#x3D;dll_interface_conflict_dllexport_assumed -Xcudafe –diag_suppress&#x3D;dll_interface_conflict_none_assumed -Xcudafe –diag_suppress&#x3D;field_without_dll_interface -Xcudafe –diag_suppress&#x3D;base_class_has_different_dll_interface -Xcompiler &#x2F;EHsc -Xcompiler &#x2F;wd4190 -Xcompiler &#x2F;wd4018 -Xcompiler &#x2F;wd4275 -Xcompiler &#x2F;wd4267 -Xcompiler &#x2F;wd4244 -Xcompiler &#x2F;wd4251 -Xcompiler &#x2F;wd4819 -Xcompiler &#x2F;MD -D__CUDA_NO_HALF_OPERATORS_ -D__CUDA_NO_HALF_CONVERSIONS__ -D__CUDA_NO_BFLOAT16_CONVERSIONS__ -D__CUDA_NO_HALF2_OPERATORS__ –expt-relaxed-constexpr -DCUDA_HAS_FP16&#x3D;1 -D__CUDA_NO_HALF_OPERATORS__ -D__CUDA_NO_HALF_CONVERSIONS__ -D__CUDA_NO_HALF2_OPERATORS__ -DTORCH_API_INCLUDE_EXTENSION_H -DTORCH_EXTENSION_NAME&#x3D;_C -D_GLIBCXX_USE_CXX11_ABI&#x3D;0 -gencode&#x3D;arch&#x3D;compute_61,code&#x3D;compute_61 -gencode&#x3D;arch&#x3D;compute_61,code&#x3D;sm_61 –use-local-env error: command ‘C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.2\\bin\\nvcc.exe’ failed with exit code 2 &amp;emsp;&amp;emsp;不用想了，就是版本问题，不过报错信息少得可怜，也看不出具体是哪里版本出错，很蠢。 问题2： D:\\Program Files\\Anaconda3\\envs\\pytorch3d\\Lib\\site-packages\\pytorch3d\\csrc\\mesh_normal_consistency\\mesh_normal_consistency_cpu.cpp: fatal error C1083: 无法打开编译器生成的文件: “ “: Invalid argument error: command ‘D:\\Program Files\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.29.30133\\bin\\HostX64\\x64\\cl.exe’ failed with exit code 1 &amp;emsp;&amp;emsp;出这个问题是因为pytorch3d的文件路径名字过长，VS不支持，把文件夹换个地方放就行了。&amp;emsp;&amp;emsp;问题原因的参考：https://www.it1352.com/1877257.html 总结&amp;emsp;&amp;emsp;pytorch3d装环境实在是过于折磨，建议还是参照其他人安装成功的软件版本，一步到位少走弯路。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://shinya754.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://shinya754.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"pytorch","slug":"pytorch","permalink":"https://shinya754.github.io/tags/pytorch/"},{"name":"pytorch3d","slug":"pytorch3d","permalink":"https://shinya754.github.io/tags/pytorch3d/"}]},{"title":"在pytorch中避免由于原地操作引起的报错","slug":"在pytorch中避免由于原地操作引起的报错","date":"2023-05-08T13:26:21.000Z","updated":"2023-05-09T07:09:58.312Z","comments":true,"path":"2023/05/08/在pytorch中避免由于原地操作引起的报错/","link":"","permalink":"https://shinya754.github.io/2023/05/08/%E5%9C%A8pytorch%E4%B8%AD%E9%81%BF%E5%85%8D%E7%94%B1%E4%BA%8E%E5%8E%9F%E5%9C%B0%E6%93%8D%E4%BD%9C%E5%BC%95%E8%B5%B7%E7%9A%84%E6%8A%A5%E9%94%99/","excerpt":"[toc] 报错的解决&amp;nbsp;&amp;nbsp;在使用pytorch训练用于攻击yolov5模型时遇到的问题，是由于yolov5模型中对于传入数据在模型中传递时使用了一些原地操作导致的。","text":"[toc] 报错的解决&amp;nbsp;&amp;nbsp;在使用pytorch训练用于攻击yolov5模型时遇到的问题，是由于yolov5模型中对于传入数据在模型中传递时使用了一些原地操作导致的。 &amp;nbsp;&amp;nbsp;报错信息如下： RuntimeError: one of the variables needed for gradient computation has been modified by an inplace operation: [torch.cuda.HalfTensor [1, 3, 128, 128, 47]], which is output 0 of SigmoidBackward0, is at version 2; expected version 0 instead. Hint: the backtrace further above shows the operation that failed to compute its gradient. The variable in question was changed in there or anywhere later. Good luck! &amp;nbsp;&amp;nbsp;翻译过来就是说梯度计算所需的变量之一已被就地操作修改，[torch.cuda.HalfTensor [1, 3, 128, 128, 47]]是我被原地修改了的那个tensor的类型和shape，SigmoidBackward0是那个tensor的grad_fn，不过这个version 2和version 0我没看懂也没找到资料，pytorch官网文档应该有写。 &amp;nbsp;&amp;nbsp;然后看看通过with torch.autograd.set_detect_anomaly(True)语句输出的操作回溯： d:\\路径\\Anaconda3\\envs\\pytorch2_0\\lib\\site-packages\\torch\\autograd\\__init__.py:200: UserWarning: Error detected in SigmoidBackward0. Traceback of forward call that caused the error: File \"d:\\Program Files\\Anaconda3\\envs\\pytorch2_0\\lib\\runpy.py\", line 197, in _run_module_as_main return _run_code(code, main_globals, None, …… …… File \"d:\\我的某个文件路径\\yolov5-5.0\\.\\models\\yolo.py\", line 122, in forward y1 = x1.sigmoid() (Triggered internally at C:\\actions-runner\\_work\\pytorch\\pytorch\\builder\\windows\\pytorch\\torch\\csrc\\autograd\\python_anomaly_mode.cpp:119.) Variable._execution_engine.run_backward( # Calls into the C++ engine to run the backward pass &amp;nbsp;&amp;nbsp;这里的回溯很明显地指出了出问题的变量是y1，那么看看y1都被干了些什么：（其实这里是yolov5 v5.0版本中的yolo.py的Detect类中的内容，不过我为了训练对抗样本所以把它改了一点） y1 = x1.sigmoid() y1[..., 0:2] = (y1[..., 0:2] * 2. - 0.5 + self.grid[1]) * self.stride[1] # xy y1[..., 2:4] = (y1[..., 2:4] * 2) ** 2 * self.anchor_grid[1] # wh &amp;nbsp;&amp;nbsp;这里对于y1，直接按坐标修改其内容是属于原地操作的一种的（注意，这里是一个原地操作并不是因为等号右边出现了y1[..., 0:2]，而是在等号左边写了y1[..., 0:2]，对y1的一部分赋值，这个操作就是一个原地操作）。要改正也很简单，不要直接像上述代码中那样修改y1里的内容，而是先把要改的内容拿出来单独做乘法，最后用torch.cat把各个部分拼接起来，修改后的代码块如下： y1 = x1.sigmoid() y1_02 = (y1[..., 0:2] * 2. - 0.5 + self.grid[1]) * self.stride[1] # xy y1_24 = (y1[..., 2:4] * 2) ** 2 * self.anchor_grid[1] # wh y1_4 = y1[..., 4:] # y1[..., 0:2] = (y1[..., 0:2] * 2. - 0.5 + self.grid[1]) * self.stride[1] # xy # y1[..., 2:4] = (y1[..., 2:4] * 2) ** 2 * self.anchor_grid[1] # wh y1 = torch.cat((y1_02, y1_24, y1_4), dim=-1) &amp;nbsp;&amp;nbsp;这样就行了。 pytorch中应该避免的原地操作&amp;nbsp;&amp;nbsp;从博客开头的那个报错信息中可以看到，在模型中，需要求梯度的tensor不应该被原地修改，但是这里的原地修改有很多博客都没有讲清楚。有些博客中建议“将代码中的”a+&#x3D;b”之类的操作改为”c &#x3D; a + b””，但是这样就会导致出现一个可能会陷入的误区：即x+=1是原地操作，那么x=x+1是不是原地操作？ &amp;nbsp;&amp;nbsp;答案是否定的，根据官网论坛中pytorch作者Adam Paszke的回答，（机翻） x &#x3D; x + 1不是原地的，因为它接受x指向的对象，创建一个新的变量，给x加1，把结果放在新的变量中，并覆盖x引用的对象以指向新的变量。没有就地修改，你只能改变Python引用(你可以检查id(x)在该行前后是否不同)。 &amp;nbsp;&amp;nbsp;此外在紧接着的下一段，他说道： 另一方面，执行x +&#x3D; 1或x[0] &#x3D; 1将就地修改变量的数据，因此不会进行复制。然而，一些函数(在你的情况下*)要求输入永远不会改变后，他们计算输出，否则他们将无法计算梯度。这就是为什么会引发错误。 &amp;nbsp;&amp;nbsp;可见在python中，对tensor按坐标赋值是一个原地操作，这也是本文上一节中出问题的原因。 参考链接1.https://blog.csdn.net/m0_38129460&#x2F;article&#x2F;details&#x2F;904050862.https://discuss.pytorch.org/t/encounter-the-runtimeerror-one-of-the-variables-needed-for-gradient-computation-has-been-modified-by-an-inplace-operation/836/4","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://shinya754.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://shinya754.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"python","slug":"python","permalink":"https://shinya754.github.io/tags/python/"},{"name":"pytorch","slug":"pytorch","permalink":"https://shinya754.github.io/tags/pytorch/"}]},{"title":"YOLOv5 v5.0 输出每个边界框所预测物体的对象概率（probability）和分类置信度（confidence）","slug":"YOLOv5-v5-0-输出每个边界框所预测物体的对象概率（probability）和分类置信度（confidence）","date":"2023-04-11T03:48:21.000Z","updated":"2023-04-11T03:58:10.857Z","comments":true,"path":"2023/04/11/YOLOv5-v5-0-输出每个边界框所预测物体的对象概率（probability）和分类置信度（confidence）/","link":"","permalink":"https://shinya754.github.io/2023/04/11/YOLOv5-v5-0-%E8%BE%93%E5%87%BA%E6%AF%8F%E4%B8%AA%E8%BE%B9%E7%95%8C%E6%A1%86%E6%89%80%E9%A2%84%E6%B5%8B%E7%89%A9%E4%BD%93%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A6%82%E7%8E%87%EF%BC%88probability%EF%BC%89%E5%92%8C%E5%88%86%E7%B1%BB%E7%BD%AE%E4%BF%A1%E5%BA%A6%EF%BC%88confidence%EF%BC%89/","excerpt":"2023.4.11这个倒是挺值得记录一下的，不过放csdn上了，就不把原文整个搬过来了链接：http://t.csdn.cn/cX8tU","text":"2023.4.11这个倒是挺值得记录一下的，不过放csdn上了，就不把原文整个搬过来了链接：http://t.csdn.cn/cX8tU","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://shinya754.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://shinya754.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"python","slug":"python","permalink":"https://shinya754.github.io/tags/python/"},{"name":"yolov5","slug":"yolov5","permalink":"https://shinya754.github.io/tags/yolov5/"}]},{"title":"Smart-Contract-Based Economical Platooning in Blockchain-Enabled Urban Internet of Vehicles","slug":"Smart-Contract-Based-Economical-Platooning-in-Blockchain-Enabled-Urban-Internet-of-Vehicles","date":"2022-10-20T09:43:46.000Z","updated":"2023-04-11T05:14:59.727Z","comments":true,"path":"2022/10/20/Smart-Contract-Based-Economical-Platooning-in-Blockchain-Enabled-Urban-Internet-of-Vehicles/","link":"","permalink":"https://shinya754.github.io/2022/10/20/Smart-Contract-Based-Economical-Platooning-in-Blockchain-Enabled-Urban-Internet-of-Vehicles/","excerpt":"2022.10.20每月一篇博客就算成功 Smart-Contract-Based Economical Platooning in Blockchain-Enabled Urban Internet of Vehicles区块链城市车联网中基于智能合约的经济车辆编队 论文发表于《IEEE Transactions on Industrial Informatics》，2019第一作者为西安电子科技大学的陈晨老师 整体介绍&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;本文设计了一种无人驾驶车辆的车队模型，该模型将路径匹配成功的车辆划分为一个车队，由队长（PH）领导，并引入了PH选择方案以激励车辆成为PH。并使用智能合约实现PH和车队成员（PM）之间基于区块链的支付，避免虚假和恶意支付。","text":"2022.10.20每月一篇博客就算成功 Smart-Contract-Based Economical Platooning in Blockchain-Enabled Urban Internet of Vehicles区块链城市车联网中基于智能合约的经济车辆编队 论文发表于《IEEE Transactions on Industrial Informatics》，2019第一作者为西安电子科技大学的陈晨老师 整体介绍&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;本文设计了一种无人驾驶车辆的车队模型，该模型将路径匹配成功的车辆划分为一个车队，由队长（PH）领导，并引入了PH选择方案以激励车辆成为PH。并使用智能合约实现PH和车队成员（PM）之间基于区块链的支付，避免虚假和恶意支付。 研究背景&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;随着城市和农村的快速发展，世界各地的汽车数量不断增加。道路变得越来越拥挤，直接导致了一系列社会和环境问题，如交通事故、通勤时间增加、资源浪费和环境污染。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;随着自动驾驶的发展，智能交通将逐步取代传统的驾驶模式。在此基础上，用车队模型代替单车驾驶模式是解决上述问题的好办法。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;一般来说，车队模型是指一个队长(PH)领导成员(PM)一起开车。PH和所有PM都有相同或相近的目的地，他们彼此之间保持一定的距离。小间距的一个明显优点是可以提高城市的交通容量，缓解交通拥堵。此外，车队模式降低了能耗，节省了5-20%的燃料成本。 待解决的问题&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1.目的地相同的不同车辆，行驶的起点往往可能不同；同一个车队中的车辆可能只是暂时顺路，目的地不一定相同；车辆在行驶过程中可能出现突发情况需要提前退出车队……&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;因此，需要有一种能够保证车队成员能够动态加入&#x2F;退出的机制。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2. 车队队长(PH)的驾驶员承担着关注驾驶情况的任务，而队员(PM)可以在车内休息，如果对PH没有激励机制，则驾驶员更愿意选择成为一名PM。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;需要一个激励机制来鼓励车辆成为PH，同时在担任PH期间负起责任。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;3.在车队创建时和行驶期间，车队的通信过程容易受到攻击，频繁的信息交互很容易导致信息泄露。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;区块链可以为联网车提供安全和隐私保障，基于区块链技术的智能合约能够保证交易的安全。 论文创新点&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;本文在车辆编队技术方面的主要贡献如下： &amp;nbsp;&amp;nbsp;1） 一种基于路径信息匹配的车辆编队机制，路径信息匹配成功的请求车辆可以加入合适的车队。 &amp;nbsp;&amp;nbsp;2） 一种计算声誉值以选择PH的方法。 &amp;nbsp;&amp;nbsp;3） 一种智能合约支付机制，迫使接受车队服务的车辆支付相应的服务费。 模型设计假设&amp;nbsp;&amp;nbsp;1）自由流交通状态下的城市道路模型和车辆流动模型等系统模型用于分析。&amp;nbsp;&amp;nbsp;2）路边单元（RSU）分布广泛，部署有边缘云，可以实时传输和处理过往车辆上传的内容，基本满足每辆车的通信需求。&amp;nbsp;&amp;nbsp;3）道路上的每辆车都配有车载单元（OBU），该单元执行简单计算，收集相关信息，并将其上传至RSU。&amp;nbsp;&amp;nbsp;4）每辆车都有一个精度约为10米的GPS导航系统，可以获取距离信息和地理位置。&amp;nbsp;&amp;nbsp;5）在车队模型中，每辆车都保存有自己的历史驾驶信息，车辆曾经经历过多次这样的行为，例如加入车队、离开车队、竞争成为PH、向PH付款、评估PH以及作为PH接受PM的评估。 系统模型&#x2F;路径匹配机制&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在图1所示的系统模型中，车辆以自由流状态沿街道行驶。图中展示了车队行驶、车辆加入车队、车辆离开车队，以及车辆和车辆、车辆和RSU交互的情况。此外，图中没有展示的信息如下：&amp;nbsp;&amp;nbsp;1） RSU：RSU相互连接，并与覆盖区域内的每辆车无线连接。RSU实时更新车队信息并协助车队调度。&amp;nbsp;&amp;nbsp;2） 初始PH：初始PH可以是单独在道路上行驶的车辆。&amp;nbsp;&amp;nbsp;3） 车队的潜在成员：在加入车队之前，车辆都是潜在的车队成员（PPM）。&amp;nbsp;&amp;nbsp;4）车队成员：PPM加入车队后，他们成为正式PM。&amp;nbsp;&amp;nbsp;5） PH轮换：为了确保安全和公平，有条件地选择一名车队成员领导该车队。 车辆请求加入车队的过程&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1.由电子地图生成由路段ID组成的路径信息，从而使得路径可以由一系列路段表示；&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2.将路径信息提交给RSU以请求匹配车队。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;车辆的路径信息表（PIT）如下图所示：其中包含：&amp;nbsp;&amp;nbsp;vj：车辆标识信息&amp;nbsp;&amp;nbsp;RSNj0：请求服务节点（车辆当前所在的位置）&amp;nbsp;&amp;nbsp;sj：车辆将要经过的道路节点集（车辆的预计行车路径）&amp;nbsp;&amp;nbsp;tj：车辆能够容忍的等待延迟 车队对车辆请求的回复&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;当车辆和车队的路径信息匹配度较高时，车辆vj有机会加入车队pi。车队的路径信息si由其中车辆的路径信息组合而成。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;车对的路径信息表（PIT）如下图所示：其中包含：&amp;nbsp;&amp;nbsp;pi：车队标识信息&amp;nbsp;&amp;nbsp;RNNi0：道路网络节点（车队当前的位置或即将到达的位置）&amp;nbsp;&amp;nbsp;si：车队将要经过的道路节点集（车队的预计行车路径），si将会随着车队的行进而不断更新&amp;nbsp;&amp;nbsp;tij：车队pi到达车辆vj处所需的时间 车辆加入车队后对车队路径信息的更新&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果车辆的路径集合sj的终点在车队路经集合si的终点之后，则车辆的加入将会导致车队路径信息更新，即集合si将会扩展。 匹配度计算&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;车辆和车队路径的匹配度MDij由以下公式计算：其中，maxlength可以由公式1算出：maxlength说人话就是车辆和车队顺路路段的最大距离。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;定义α为匹配阈值（默认为1&#x2F;2），则有如下3种匹配情况：&amp;nbsp;&amp;nbsp;1. MDij&lt;α，匹配失败，vj继续请求；&amp;nbsp;&amp;nbsp;2. MDij&gt;&#x3D;α，但是tij&gt;tj（即匹配度足够，但是pi无法在vj可以等待的时间内到达），匹配失败，vj继续请求；&amp;nbsp;&amp;nbsp;3. MDij&gt;&#x3D;α，且tij&lt;&#x3D;tj，匹配成功，vj成为pi的成员vpi PH选择机制&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;由于车队中的车辆不会永久地处于车队内，需要一种PH轮换选择机制来保证车队的持续运行。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;为了找到有经验且可靠的车辆来担任PH，定义“声誉值”（Reputation）作为衡量标准，声誉值取决于PM对PH的评价。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;当PM离开排&#x2F;PH轮换时（图6），PM对PH的服务进行评估，PM的操作屏幕上将弹出评估窗口（就像对网约车司机打分），只需对每个问题选择星级，问题必须简短以便PM快速评价。预设计的一些问题如图7左侧（开车经验&#x2F;危机处理&#x2F;收费合理）。 声誉值计算机制&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打分的结果由公式2计算：其中，𝑆𝐶𝑝ℎ𝑖^𝑣𝑗^是车队pi中，车辆vj对PH的最终评分，𝑆𝐶𝑘^𝑣𝑗^是车辆vj对第k道题目的评分，wk是每道题的权重。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;由于评估分数一定分布在区间[0,1]内，评估分数可以用α&#x3D;1的贝塔分布来拟合，贝塔分布的概率密度函数如下（用𝑆𝐶𝑝ℎ𝑖^𝑣𝑗^代替随机变量X）：&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;评分均值rei和β的关系如公式4所示，然后据此对β进行最大似然估计得到β的估计值如公式5所示：最终定义声誉值R如下：其中R0&#x3D;0.7是初始分数，M为车队车辆数，N为PH得到评价的次数。最终R值随着N和rei变化而变化。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;计算并排序每辆车的最终声誉值。将声誉值和匹配度结合以确定PH的选择。当当前PH的匹配度MDij&lt;1&#x2F;2时应当更换PH，在其余MDij&gt;&#x3D;1&#x2F;2的PM中选择声誉值最高的成为PH。 基于智能合约的安全通信&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;没看懂，这里汇报完老师给新任务了，摆了&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;下一篇智能汽车和5G相关 总体流程图","categories":[{"name":"论文总结","slug":"论文总结","permalink":"https://shinya754.github.io/categories/%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://shinya754.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"区块链","slug":"区块链","permalink":"https://shinya754.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"智能汽车","slug":"智能汽车","permalink":"https://shinya754.github.io/tags/%E6%99%BA%E8%83%BD%E6%B1%BD%E8%BD%A6/"},{"name":"读论文","slug":"读论文","permalink":"https://shinya754.github.io/tags/%E8%AF%BB%E8%AE%BA%E6%96%87/"}]},{"title":"AJAX","slug":"AJAX","date":"2022-09-01T03:44:36.000Z","updated":"2022-09-01T05:16:50.741Z","comments":true,"path":"2022/09/01/AJAX/","link":"","permalink":"https://shinya754.github.io/2022/09/01/AJAX/","excerpt":"2022.09.01 学习资料：https://www.bilibili.com/video/BV1WC4y1b78y express相关&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;express是一个基于node.js的web应用框架，感觉上约等于flask或者tomcat之类的东西。 express的基础使用：&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在安装好express后，在每个js文件使用express之前先引入express并创建对象实例。 app.get(路径，回调函数):&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;创建一个使用get方式请求的路由，当访问 &#x2F;路径 时，将会发送get请求并且调用回调函数，回调函数的参数是请求报文和响应报文（可以有第三个参数next）&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;此外还有post、all等接收其他请求方式的函数。app.listen(端口，回调函数):监听指定端口，访问服务时需要访问host+port，默认host是127.0.0.1","text":"2022.09.01 学习资料：https://www.bilibili.com/video/BV1WC4y1b78y express相关&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;express是一个基于node.js的web应用框架，感觉上约等于flask或者tomcat之类的东西。 express的基础使用：&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在安装好express后，在每个js文件使用express之前先引入express并创建对象实例。 app.get(路径，回调函数):&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;创建一个使用get方式请求的路由，当访问 &#x2F;路径 时，将会发送get请求并且调用回调函数，回调函数的参数是请求报文和响应报文（可以有第三个参数next）&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;此外还有post、all等接收其他请求方式的函数。app.listen(端口，回调函数):监听指定端口，访问服务时需要访问host+port，默认host是127.0.0.1 https://www.runoob.com/nodejs/nodejs-express-framework.html //1.引入express const express = require(\"express\"); //2.创建应用对象 const app=express(); //3.创建路由规则 //request是对请求报文的封装 //response是对响应报文的封装 app.get(\"/\",function(request,response)&#123; //设置响应头，设置允许跨域 response.setHeader(\"Access-Control-Allow-Origin\",\"*\"); //设置响应 response.send(\"hello express\"); &#125;); //4.监听端口启动服务 app.listen(8000,function()&#123; console.log(\"服务已经启动，8000端口监听中......\") &#125;); 设置响应头以按规则允许请求头中的自定义键：//设置响应头，设置允许自定义请求头键 response.setHeader(\"Access-Control-Allow-Headers\",\"*\"); 其中 * 指任意匹配（似乎不是正则表达式，而是指定具体的请求头中key名）以JSON字符串的形式返回一个对象： app.all(\"/json-server\",function(request,response)&#123; //准备一个对象以返回 var data=&#123; name:\"shinya\", age:\"15\" &#125; //使用JSON.stringify(obj)方法来将对象转换为字符串 let str=JSON.stringify(data); //设置响应 response.send(str); &#125;); 延迟响应：使用setTimeout(function, delayTime)来设置响应延时。 app.get(\"/delay\",(req,resp)=>&#123; resp.setHeader(\"Access-Control-Allow-Origin\",\"*\"); //第一个参数是执行的方法，第二个是延时（ms） setTimeout(function()&#123; resp.send(\"延时响应\"); &#125;,3000); &#125;) Ajax发出请求&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在原生AJAX中，进行一次请求分为4步：创建XMLHttpRequest对象xhr，调用open方法指定请求方式和请求路径，发送请求，处理响应结果。 let btn=document.getElementById(\"btn\"); //按钮点击事件 btn.onclick=function()&#123; //1.创建对象 const xhr=new XMLHttpRequest(); //2.初始化 设置请求方法和url xhr.open(\"GET\",\"http://127.0.0.1:8000/server\"); //xhr.open(\"GET\",\"http://www.baidu.com\"); //报错，百度没有允许跨域。 //3.发送 xhr.send(); //4.事件绑定 处理服务端返回的结果 //onreadystatechange会在readystate改变时调用回调函数 // 0 - 未初始化 // 1 - open方法调用完毕 // 2 - send方法调用完毕 // 3 - 服务端返回了部分结果 // 4 - 服务端返回了所有结果 xhr.onreadystatechange=function()&#123; if(xhr.readyState===4)&#123; if(xhr.status>=200 &amp;&amp;xhr.status&lt;300)&#123; console.log(xhr.status);//状态码 console.log(xhr.statusText);//状态字符串 console.log(xhr.getAllResponseHeaders());//所有响应头 console.log(xhr.response);//响应体 //将结果展示在div内 let textArea=document.getElementById(\"textArea\"); textArea.innerText=xhr.response; &#125; &#125; &#125; &#125; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;*注意：在GET方式中，参数必须在url中传递，不能在xhr.send()方法中传递，而POST方式下，参数必须在xhr.send()方法中传递，不能在url中显示传递，如下所示： xhr.send(\"test from send() POST\"); &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;此外，一般而言约定俗成的传参格式有两种，第一种是形如”a&#x3D;100&amp;b&#x3D;200”，另一种是Json 设置请求头（POST）&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在请求发出（send）之前调用xhr.setHeader(key,value)方法以设置请求头 //设置请求头 xhr.setRequestHeader(\"Content-Type\",\"application/x-www-form-urlencoded\"); xhr.setRequestHeader(\"name\",\"Shinya\"); &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;*注意：如果使用了自定义而非预定义的请求头，则浏览器在发出此请求时会同时发出一个OPTION请求以确认服务器是否允许接收此请求头，如果不能则会报错。 解析不同类型的响应体数据&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;此处以JSON为例，在得到响应的JSON串之后，有手动转换和自动转换两种方式：&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1.手动转换：使用JSON.parse()方法 //1.手动数据转换 //传输过来的xhr.response是一个字符串，所以使用JSON.parse()转换为JSON对象 let data=JSON.parse(xhr.response); console.log(data); &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2.自动转换：设置响应体数据类型 //在发送请求（send）之前设置响应体数据类型，则会按照此数据类型接收数据 xhr.responseType=\"json\"; //2.自动数据转换，无需再调用parse方法，得到的xhr.response本身就是一个JSON对象 let data=xhr.response; console.log(data) 超时&#x2F;网络错误处理&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1.超时处理，在响应超过预设时间时，调用xhr.ontimeout定义的回调函数，猜测xhr.ontimeout初始为空函数。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;*注意：超时后，请求会自动被取消 //设置超时时间（ms） xhr.timeout=2000; //超时回调函数 xhr.ontimeout=function()&#123; alert(\"响应超时，请检查网络！\"); &#125; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2.网络错误处理，在发现网络出错时调用xhr.onerror定义的回调函数 //网络错误回调 xhr.onerror=function()&#123; alert(\"网络错误！\"); &#125; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;手动取消请求： xhr.abort() &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;防止多次重复请求：&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;设置一个flag，isSending，使其在xhr.send()之后为true，在xhr.readyState&#x3D;&#x3D;&#x3D;4后变为false，并且在发出请求的按钮按下之后 使用jQuery发送请求：&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;jQuery.get()方法：&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;以get方式发送一个请求，接收1-4个参数，依次为url、数据、回调函数、接收数据类型，其中回调函数自带3个可选参数，data（响应体）、status（响应状态）、xhr（xhr对象）&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;https://www.runoob.com/jquery/ajax-get.html jQuery.get(\"http://127.0.0.1:8000/jQuery-server\",data,function(data)&#123; //此函数接收的参数data是响应体 console.log(data); &#125;,\"json\") &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;post() 方法与之类似。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;jQuery.ajax()方法：&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;发送ajax请求，请求类型、请求地址等都可以设置，非常灵活。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;https://jquery.cuishifeng.cn/jQuery.Ajax.html $(\"button\").eq(2).click(function()&#123; //ajax方法接收的是一个对象，由花括号包裹 $.ajax(&#123; url:\"http://127.0.0.1:8000/jQuery-server\", //请求中携带的数据 data:&#123; name:\"shinya\", age:15 &#125;, type:\"GET\", dataType:\"json\", //成功时的回调 success:function(data)&#123; console.log(data) &#125;, timeout:2000, //出错时的回调 error:function()&#123; alert(\"出错！\") &#125;, //请求头 headers:&#123; head:\"any\" &#125; &#125;) &#125;) JSONP：一种跨域请求方案&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;html中，img、iframe、script等标签自带跨域访问能力（如script中指定src以获取并执行一段js代码），jsonp就是利用了script标签的这种能力来实现跨域访问。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;*即：不通过get()等方法来手动发请求，而是借助script标签来访问外部链接的资源，获取到的资源将会按照js的语法进行解析和执行。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;*注意，使用此方法只能够发送GET请求。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;应用：使用jsonp请求一段JSON代码并解析执行&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;服务端： app.all(\"/check-username\",function(req,resp)&#123; let data=&#123; exist:1, msg:\"用户名已经存在\" &#125;; let str=JSON.stringify(data); //使用反单引号``包裹的字符串可以使用$&#123;变量名&#125;来完成字符串的注入拼接，这是ES6新特性 resp.send(`handle($&#123;str&#125;)`) &#125;) &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;客户端： &lt;script> hint=document.getElementById(\"hint\"); input=document.getElementById(\"username\"); //data应为一个对象 function handle(data)&#123; input.style.border=\"solid 2px red\"; hint.innerText=data.msg &#125; input.onblur=function()&#123; let username=this.value; //向服务端发出请求，检测用户名是否存在 //1.创建script标签 let scri=document.createElement(\"script\"); //2.设置标签的src属性 scri.src=\"http://127.0.0.1:8000/check-username\"; //3.将标签插入到body中 document.body.appendChild(scri) &#125; &lt;/script> &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;此处，向body中插入了新建的标签script，标签被新建后将会获取其src属性中的资源，访问&#x2F;check-username路径之后，得到了服务端在resp.send()中发送的内容：“handle(${str})”，此后将其执行，即是执行了客户端所定义的handle方法。","categories":[{"name":"实用","slug":"实用","permalink":"https://shinya754.github.io/categories/%E5%AE%9E%E7%94%A8/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://shinya754.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Web","slug":"Web","permalink":"https://shinya754.github.io/tags/Web/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://shinya754.github.io/tags/JavaScript/"},{"name":"AJAX","slug":"AJAX","permalink":"https://shinya754.github.io/tags/AJAX/"}]},{"title":"Python爬虫","slug":"Python爬虫","date":"2022-07-28T02:37:44.000Z","updated":"2022-09-01T03:48:15.365Z","comments":true,"path":"2022/07/28/Python爬虫/","link":"","permalink":"https://shinya754.github.io/2022/07/28/Python%E7%88%AC%E8%99%AB/","excerpt":"2022.07.28 学习资料：https://www.bilibili.com/video/BV12E411A7ZQ Python爬虫基础部分urllib库创建请求get方式&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用 urllib.request.urlopen() 方法（需要引包），指定请求链接（需要加http:&#x2F;&#x2F;）和超时阈值等，然后使用 read() 方法将得到的返回信息打印，decode()方法用于进行格式化。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;此处使用了 try&#x2F;except进行错误捕获，主要是为了不在超时的情况下报一大堆错。","text":"2022.07.28 学习资料：https://www.bilibili.com/video/BV12E411A7ZQ Python爬虫基础部分urllib库创建请求get方式&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用 urllib.request.urlopen() 方法（需要引包），指定请求链接（需要加http:&#x2F;&#x2F;）和超时阈值等，然后使用 read() 方法将得到的返回信息打印，decode()方法用于进行格式化。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;此处使用了 try&#x2F;except进行错误捕获，主要是为了不在超时的情况下报一大堆错。 #使用get方式请求 import urllib.request #超时处理 try: timeout = 0.01 response = urllib.request.urlopen(\"http://www.baidu.com\",timeout=timeout) print(response.read().decode('utf-8')) #对获取到的网页进行utf-8解码 except urllib.error.URLError as e: print(\"ERROR! Time out of \"+str(timeout)+\"s!\") post方式&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用post方式请求时，必须要附带一些表单信息，否则无法请求。此处使用 urllib.parse.urlencode() 方法并套一个 bytes 方法来创建附带的数据，附带的这些信息会附带在请求头中。 #使用post方式请求，post不能不传参数直接请求 import urllib.parse #bytes:创建二进制数据，&#123;\"a\":\"b\"&#125;:键值对，其中a为key，b为value data = bytes(urllib.parse.urlencode(&#123;\"hello\":\"world\"&#125;),encoding=\"utf-8\") response = urllib.request.urlopen(\"http://httpbin.org/post\",data=data) print(response.read().decode(\"utf-8\"))#解码可以顺便解码\\n等，保证格式好看 创建请求头&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;对请求头进行伪装以避开某些网站的检测&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用 urllib.request.Request() 方法来使用创建好的请求头，其中可以指定url、附带信息、请求头、请求种类等&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;之后还是得用 urlopen 打开链接 #创建请求头 #url=\"http://httpbin.org/post\" url=\"http://www.douban.com\" #若不设置header，会被豆瓣认出来并说我是个茶壶 headers=&#123; \"user-agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.163 Safari/537.36\" &#125; data=bytes(urllib.parse.urlencode(&#123;'name':'eric'&#125;),encoding=\"utf-8\") req=urllib.request.Request(url=url,data=data,headers=headers,method=\"POST\") response=urllib.request.urlopen(req) print(response.read().decode(\"utf-8\")) 查看请求状态和响应头等#看看请求状态和请求头 response = urllib.request.urlopen(\"https://www.baidu.com\") print(response.status)#200 #print(response.getheaders())#获取整个响应头 print(response.getheader(\"Date\"))#注意headers和header Beautiful Soup 4 库提取响应内容from bs4 import BeautifulSoup #创建BS实例 file = open(\"testPackages\\douban.html\",\"rb\")#rb是读字节流 html=file.read().decode(\"utf-8\")#打开html文件 bs=BeautifulSoup(html,\"html.parser\")#第一个参数是要解析的文件，第二个参数是解析方式 Tag&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;标签及其中的所有内容（包括其中的低级标签），会找到第一个符合的标签 print(bs.title)#如果输出bs.title的类型，则是Tag print(bs.title.string)#只取标签中的文字内容 print(type(bs.title)) '''输出： &lt;title>豆瓣电影 Top 250&lt;/title> 豆瓣电影 Top 250 &lt;class 'bs4.element.Tag'> ''' NavigableString&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;获取标签里的内容（字符串） print(bs.a.string)# print(type(bs.a.string)) ''' 登录/注册 &lt;class 'bs4.element.NavigableString'> ''' BeautifulSoup&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;获取整个文档 #print(bs.head.contents)#返回一个字典类型，内容是head下面的所有标签 print(bs.head.contents[1])#获取字典中的第一个元素（下标从0开始） ''' &lt;meta content=\"text/html; charset=utf-8\" http-equiv=\"Content-Type\"/> （这是html中的第一个标签，上述字典中第0个元素是'\\n'） ''' Comment&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;特殊的NavigableString，但是会自动过滤注释符号 print(bs.a.string)#如果其中有形如&lt;!--abc-->的注释内容，其会被自动转换为abc 提取标签下的所有属性print(bs.a.attrs)#字典类型 ''' &#123;'href': 'https://accounts.douban.com/passport/login?source=movie', 'class': ['nav-login'], 'rel': ['nofollow']&#125; ''' 文档的搜索&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用bs.find_all()或者bs.select()方法定位某些标签或者文字内容。 （1）以字符串匹配或者方法查找&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;理解：bs.find_all方法首先会获取到文档中的所有标签，然后根据方法传入的参数来筛选符合要求的标签，当参数是方法名时，将每一个标签传入方法，根据返回值判断这个标签是否可用。 #①字符串查找：返回与传入字符串完全匹配的内容 t_list = bs.find_all(\"span\")#返回所有span标签（包括其子标签） #②正则表达式：调用正则对象的search()方法来匹配内容 t_list = bs.find_all(re.compile(\"s\"))#返回所有包含s的标签（包括其子标签） #③函数：传入函数名，根据函数的内容来查找（类似C++和C#中sort函数排序时可以传入自定义比较函数） def value_is_exist(tag): return tag.has_attr(\"value\") t_list = bs.find_all(value_is_exist)#返回所有具有value属性的标签 （2）kwargs：查找某属性为某特定值的标签&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;参数中指定想要的标签中的属性内容 t_list = bs.find_all(value=\"unwatched\")#找出所有value属性值为\"unwatched\"的标签 t_list = bs.find_all(class_=True)#找到所有拥有class属性的标签（class关键字为了消除歧义，需要使用class_来代替） （3）text：查找符合某规则的标签中的文本&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用text时只会返回标签中的文本，不会返回整个标签&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;理解：一个标签的内容也被视作属性，其key为text，value为其中的内容 t_list = bs.find_all(text=\"豆瓣\")#完全匹配，注意使用text时只会返回标签中的文本，不会返回整个标签 t_list = bs.find_all(text=[\"豆瓣\",\"让子弹飞\",\"后页\"])#同时找多个，返回顺序是其在文档中本来的顺序 t_list = bs.find_all(text = re.compile(\"\\d\"))#使用正则表达式找出所有包含数字的文本 （4）limit参数：限定查找出的条目数量t_list = bs.find_all(text=[\"豆瓣\",\"让子弹飞\",\"后页\"],limit=3)#总之就是在原来的基础上截断了，与上面那个的结果相比只有其前三条 （5）css选择器：使用select()方法按照css选择器语法定位标签t_list = bs.select(\"title\")#所有的title t_list = bs.select(\".quote\")#所有class为quote的标签 t_list = bs.select(\"#footer\") t_list = bs.select(\"a[href='https://movie.douban.com/tv/']\")#找a标签中href属性为特定值的 t_list = bs.select(\"head > title\")#找head下面的title t_list = bs.select(\".rating45-t ~ .rating_num\")#找前一标签同级的后一标签 实例测试：提取豆瓣TOP250中电影的链接、片名等信息&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;以下是一部电影的信息 &lt;div class=\"item\"> &lt;div class=\"pic\"> &lt;em class=\"\">1&lt;/em> &lt;a href=\"https://movie.douban.com/subject/1292052/\"> &lt;img width=\"100\" alt=\"肖申克的救赎\" src=\"https://img2.doubanio.com/view/photo/s_ratio_poster/public/p480747492.webp\" class=\"\"> &lt;/a> &lt;/div> &lt;div class=\"info\"> &lt;div class=\"hd\"> &lt;a href=\"https://movie.douban.com/subject/1292052/\" class=\"\"> &lt;span class=\"title\">肖申克的救赎&lt;/span> &lt;span class=\"title\">&amp;nbsp;/&amp;nbsp;The Shawshank Redemption&lt;/span> &lt;span class=\"other\">&amp;nbsp;/&amp;nbsp;月黑高飞(港) / 刺激1995(台)&lt;/span> &lt;/a> &lt;span class=\"playable\">[可播放]&lt;/span> &lt;/div> &lt;div class=\"bd\"> &lt;p class=\"\"> 导演: 弗兰克·德拉邦特 Frank Darabont&amp;nbsp;&amp;nbsp;&amp;nbsp;主演: 蒂姆·罗宾斯 Tim Robbins /...&lt;br> 1994&amp;nbsp;/&amp;nbsp;美国&amp;nbsp;/&amp;nbsp;犯罪 剧情 &lt;/p> &lt;div class=\"star\"> &lt;span class=\"rating5-t\">&lt;/span> &lt;span class=\"rating_num\" property=\"v:average\">9.7&lt;/span> &lt;span property=\"v:best\" content=\"10.0\">&lt;/span> &lt;span>2649976人评价&lt;/span> &lt;/div> &lt;p class=\"quote\"> &lt;span class=\"inq\">希望让人自由。&lt;/span> &lt;/p> &lt;/div> &lt;/div> &lt;/div> &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;分别对需要的每一种类信息创建各自的正则表达式 #影片详情链接 linkPat = re.compile(r'&lt;a href=\"(.*?)\">') #注意：findall()中，如果传入的正则表达式含有括号，则只会返回括号内的内容 def getData(baseurl): datalist = [] for i in range(0,10):#共10页 url=baseurl+str(i*25) html = askUrl(url)#访问链接获取到目标html文件 #2.逐一解析数据 bs = BeautifulSoup(html,\"html.parser\") list = bs.find_all(\"div\",class_=\"item\")#解析发现，每个电影的相关信息都被class为item的div包裹 for item in list: #print(item) #测试：获取全部电影的全部信息 data=[] item = str(item)#re.findall要求传入字符串 #影片详情的链接 link = re.findall(linkPat ,item)[0]#如果会获取到多个，则可以只取第一个，否则会得到一个列表 print(link) return datalist &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;解析完成后，将其存储到excel表格中 import xlwt def SaveData(datalist, savePath): print(\"saving...\") # 先创建好表格 workBook = xlwt.Workbook(encoding=\"utf-8\") # 创建WorkBook对象 workSheet = workBook.add_sheet('豆瓣电影') # 添加工作表 # 添加表头 colName = (\"影片详情链接\", \"影片图片链接\", \"中文片名\", \"外文片名\", \"分数\", \"评价人数\", \"一句话概括\", \"其他信息\") for i in range(0, 8): workSheet.write(0, i, colName[i]) for i in range(0, 250): for j in range(0, 8): # 隐患：最好将8修改为len(colName) workSheet.write(i+1, j, datalist[i][j]) print(\"第%d个写入完成\" % (i+1)) workBook.save(savePath) return None 将数据存储到sqlite数据库中&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;注意：在创建sql语句时，字符串类型的数据必须加双引号，数值类型可加可不加。 def SaveData2DB(datalist, savePath): Init_DB(savePath=savePath) conn = sqlite3.connect(savePath) cur = conn.cursor() for data in datalist: for index in range(len(data)): data[index] = '\"'+str(data[index])+'\"' sql = ''' insert into tblMovie250 (link,image,cTitle,oTitle,rating,judgeNum,generalization,info) values (%s) ''' % \",\".join(data) cur.execute(sql) conn.commit() cur.close() conn.close() return None 异步爬取（以bilibili评论区内容为例）&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;某些网站的数据并不会一次性加载完（喜欢我AJAX吗），而是在用户做出某些特定操作后才会加载（如b站评论区，滚动条滑到底时才会继续加载下面的评论）。这种异步加载的实现逻辑是在触发需要加载的行为时，浏览器向AJAX发送请求，并由AJAX从服务器处获取到新加载的内容（JSON串）。在异步爬取中，我们只需要分析AJAX向服务器获取新内容时的请求链接，然后使用urllib来请求这个链接即可。 0.查看返回的JSON串格式 1.AskUrldef AskUrl(url): ''' 根据访问链接获取对应的html页面 return: html页面 ''' # 若不设置header，会被豆瓣认出来并说我是个茶壶 head = &#123; \"user-agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.163 Safari/537.36\" &#125; req = urllib.request.Request(url=url, headers=head) try: response = urllib.request.urlopen(req) html = response.read().decode(\"utf-8\") # print(html) except urllib.error.URLError as e: if hasattr(e, \"code\"): print(e.code) if hasattr(e, \"reason\"): print(e.reason) return html 2.AskJsonByPage，按页号获取JSON串将页数设置为1000可以看到能够获取一个JSON串，但是没有评论内容，可以将此作为循环结束标志。 baseUrlFront = \"https://api.bilibili.com/x/v2/reply/main?csrf=d2f1171678cefe4350b2a43a023f6a4c&amp;mode=3&amp;next=\" baseUrlAfter = \"&amp;oid=800272415&amp;plat=1&amp;type=1\" def AskJsonByPage(index): ''' 根据页号来访问评论区，页号从1开始 return: 获取到的JSON串 ''' url = baseUrlFront+str(index)+baseUrlAfter # 分析JSON串得知，replies:\"null\"代表无内容 resp = AskUrl(url=url) jsonStr = json.loads(resp) if(jsonStr[\"data\"][\"replies\"] is None): return \"Empty\" else: commentLlist = jsonStr[\"data\"][\"replies\"] for item in commentLlist: print(item[\"member\"][\"uname\"] + \" : \" + item[\"content\"][\"message\"]) return \"Success\" 3.循环爬取页面&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;注意：如果短时间请求次数过多，即使伪装了请求头也可能会被ban IP，一个解决方案是每爬一页停一秒。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;此处设置循环上限为1000，防止死循环，如果某视频评论页数大于1000则再调整即可。 def main(): index = 1 while(AskJsonByPage(index=index) != \"Empty\" and index &lt;= 1000): index += 1 # AskJsonByPage(1000) return None 其他内容&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;包括WordCloud词云、Flask后端服务组件、Sqlite数据库等，写在石墨文档了","categories":[{"name":"实用","slug":"实用","permalink":"https://shinya754.github.io/categories/%E5%AE%9E%E7%94%A8/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://shinya754.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Python","slug":"Python","permalink":"https://shinya754.github.io/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://shinya754.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"Web","slug":"Web","permalink":"https://shinya754.github.io/tags/Web/"}]},{"title":"力扣1994.好子集的数目","slug":"力扣1994-好子集的数目","date":"2022-02-22T13:23:56.000Z","updated":"2022-02-22T13:35:15.363Z","comments":true,"path":"2022/02/22/力扣1994-好子集的数目/","link":"","permalink":"https://shinya754.github.io/2022/02/22/%E5%8A%9B%E6%89%A31994-%E5%A5%BD%E5%AD%90%E9%9B%86%E7%9A%84%E6%95%B0%E7%9B%AE/","excerpt":"2022.02.22 1994.好子集的数目https://leetcode-cn.com/problems/the-number-of-good-subsets/ 给你一个整数数组 nums 。如果 nums 的一个子集中，所有元素的乘积可以表示为一个或多个 互不相同的质数 的乘积，那么我们称它为 好子集 。 比方说，如果 nums = [1, 2, 3, 4] ：[2, 3] ，[1, 2, 3] 和 [1, 3] 是好子集，乘积分别为 6 = 2*3 ，6 = 2*3 和 3 = 3 。[1, 4] 和 [4] 不是 好 子集，因为乘积分别为 4 = 2*2 和 4 = 2*2 。请你返回 nums 中不同的 好 子集的数目对 10^9 + 7 取余 的结果。 nums 中的 子集 是通过删除 nums 中一些（可能一个都不删除，也可能全部都删除）元素后剩余元素组成的数组。如果两个子集删除的下标不同，那么它们被视为不同的子集。","text":"2022.02.22 1994.好子集的数目https://leetcode-cn.com/problems/the-number-of-good-subsets/ 给你一个整数数组 nums 。如果 nums 的一个子集中，所有元素的乘积可以表示为一个或多个 互不相同的质数 的乘积，那么我们称它为 好子集 。 比方说，如果 nums = [1, 2, 3, 4] ：[2, 3] ，[1, 2, 3] 和 [1, 3] 是好子集，乘积分别为 6 = 2*3 ，6 = 2*3 和 3 = 3 。[1, 4] 和 [4] 不是 好 子集，因为乘积分别为 4 = 2*2 和 4 = 2*2 。请你返回 nums 中不同的 好 子集的数目对 10^9 + 7 取余 的结果。 nums 中的 子集 是通过删除 nums 中一些（可能一个都不删除，也可能全部都删除）元素后剩余元素组成的数组。如果两个子集删除的下标不同，那么它们被视为不同的子集。 示例 1： 输入：nums = [1,2,3,4] 输出：6 解释：好子集为： - [1,2]：乘积为 2 ，可以表示为质数 2 的乘积。 - [1,2,3]：乘积为 6 ，可以表示为互不相同的质数 2 和 3 的乘积。 - [1,3]：乘积为 3 ，可以表示为质数 3 的乘积。 - [2]：乘积为 2 ，可以表示为质数 2 的乘积。 - [2,3]：乘积为 6 ，可以表示为互不相同的质数 2 和 3 的乘积。 - [3]：乘积为 3 ，可以表示为质数 3 的乘积。 示例 2： 输入：nums = [4,2,3,15] 输出：5 解释：好子集为： - [2]：乘积为 2 ，可以表示为质数 2 的乘积。 - [2,3]：乘积为 6 ，可以表示为互不相同质数 2 和 3 的乘积。 - [2,15]：乘积为 30 ，可以表示为互不相同质数 2，3 和 5 的乘积。 - [3]：乘积为 3 ，可以表示为质数 3 的乘积。 - [15]：乘积为 15 ，可以表示为互不相同质数 3 和 5 的乘积。 提示： 1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 30 &amp;emsp;学到的知识点：状态压缩+动态规划&amp;emsp;这也能dp.jpg&amp;emsp;这个看到数据范围后将每个数字的因子的状态压缩为二进制数的方式确实很机智。&amp;emsp;不知道写点什么好（低情商：没理解透彻），放个题解链接吧。&amp;emsp;以及我直到AC完了还不知道题解为啥要倒序遍历mask，反正我没倒序。&amp;emsp;代码：（C++） class Solution &#123; public: int numberOfGoodSubsets(vector&lt;int>&amp; nums) &#123; long int mod=1000000007; int primes[10]=&#123;2,3,5,7,11,13,17,19,23,29&#125;; int count[34]=&#123;0&#125;; int n=nums.size(); int ans=0; for(int i=0;i&lt;n;i++)&#123; count[nums[i]]++; &#125; int mask=1&lt;&lt;10; long int f[1&lt;&lt;10]=&#123;1&#125;; for(int i=2;i&lt;=30;i++)&#123; if(count[i]==0) continue; int masked_i=0; bool ok=true; int temp_i=i; for(int j=0;j&lt;10;j++)&#123; int c=0; while(temp_i%primes[j]==0 &amp;&amp; temp_i>1)&#123; masked_i|=(1&lt;&lt;j); c++; temp_i/=primes[j]; &#125; if(c>1)&#123; ok=false; break;//当i内有某个因子多于2次时，这个i必不能用 &#125; &#125; if(!ok) continue; for(int j=0;j&lt;mask;j++)&#123; if(f[j]==0)continue; if((j &amp; masked_i)==0)&#123; f[j|masked_i]=(f[j|masked_i]+f[j]*count[i])%mod; &#125; &#125; &#125; for(int i=1;i&lt;mask;i++)&#123; ans=(ans+f[i])%mod; &#125; for(int i=0;i&lt;count[1];i++)&#123; ans=ans*2%mod; &#125; return ans; &#125; &#125;;","categories":[{"name":"力扣做题笔记","slug":"力扣做题笔记","permalink":"https://shinya754.github.io/categories/%E5%8A%9B%E6%89%A3%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://shinya754.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"力扣","slug":"力扣","permalink":"https://shinya754.github.io/tags/%E5%8A%9B%E6%89%A3/"},{"name":"C++","slug":"C","permalink":"https://shinya754.github.io/tags/C/"},{"name":"动态规划","slug":"动态规划","permalink":"https://shinya754.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"力扣838.推多米诺","slug":"力扣838-推多米诺","date":"2022-02-21T12:51:43.000Z","updated":"2022-02-21T13:11:56.283Z","comments":true,"path":"2022/02/21/力扣838-推多米诺/","link":"","permalink":"https://shinya754.github.io/2022/02/21/%E5%8A%9B%E6%89%A3838-%E6%8E%A8%E5%A4%9A%E7%B1%B3%E8%AF%BA/","excerpt":"2022.02.21 838.推多米诺https://leetcode-cn.com/problems/push-dominoes/ n 张多米诺骨牌排成一行，将每张多米诺骨牌垂直竖立。在开始时，同时把一些多米诺骨牌向左或向右推。 每过一秒，倒向左边的多米诺骨牌会推动其左侧相邻的多米诺骨牌。同样地，倒向右边的多米诺骨牌也会推动竖立在其右侧的相邻多米诺骨牌。 如果一张垂直竖立的多米诺骨牌的两侧同时有多米诺骨牌倒下时，由于受力平衡， 该骨牌仍然保持不变。 就这个问题而言，我们会认为一张正在倒下的多米诺骨牌不会对其它正在倒下或已经倒下的多米诺骨牌施加额外的力。 给你一个字符串 dominoes 表示这一行多米诺骨牌的初始状态，其中： dominoes[i] = &#39;L&#39;，表示第 i 张多米诺骨牌被推向左侧，dominoes[i] = &#39;R&#39;，表示第 i 张多米诺骨牌被推向右侧，dominoes[i] = &#39;.&#39;，表示没有推动第 i 张多米诺骨牌。返回表示最终状态的字符串。","text":"2022.02.21 838.推多米诺https://leetcode-cn.com/problems/push-dominoes/ n 张多米诺骨牌排成一行，将每张多米诺骨牌垂直竖立。在开始时，同时把一些多米诺骨牌向左或向右推。 每过一秒，倒向左边的多米诺骨牌会推动其左侧相邻的多米诺骨牌。同样地，倒向右边的多米诺骨牌也会推动竖立在其右侧的相邻多米诺骨牌。 如果一张垂直竖立的多米诺骨牌的两侧同时有多米诺骨牌倒下时，由于受力平衡， 该骨牌仍然保持不变。 就这个问题而言，我们会认为一张正在倒下的多米诺骨牌不会对其它正在倒下或已经倒下的多米诺骨牌施加额外的力。 给你一个字符串 dominoes 表示这一行多米诺骨牌的初始状态，其中： dominoes[i] = &#39;L&#39;，表示第 i 张多米诺骨牌被推向左侧，dominoes[i] = &#39;R&#39;，表示第 i 张多米诺骨牌被推向右侧，dominoes[i] = &#39;.&#39;，表示没有推动第 i 张多米诺骨牌。返回表示最终状态的字符串。 示例 1： 输入：dominoes = \"RR.L\" 输出：\"RR.L\" 解释：第一张多米诺骨牌没有给第二张施加额外的力。 示例 2： 输入：dominoes = \".L.R...LR..L..\" 输出：\"LL.RR.LLRRLL..\" 提示： n == dominoes.length 1 &lt;= n &lt;= 105 dominoes[i] 为 'L'、'R' 或 '.' &amp;emsp;学到的知识点：…&amp;emsp;看到这题最开始想的是就嗯模拟，想了想那样就O(n^2)时间了，于是想到用栈，栈中存储遍历到的最后一个R，但是实际上只需要存储一个R就行了，于是使用一个bool变量记录了上一个推的是不是R，并且根据遍历到的当前位置的不同推法，分为4种情况。&amp;emsp;代码如下：（C++） class Solution &#123; public: string pushDominoes(string dominoes) &#123; string ans=dominoes; int n=dominoes.size(); bool last_is_right=false;//记录前一个推的是不是R int index=0;//记录“当前看来需要处理的序列的起始位置” if(ans[0]=='R')&#123; last_is_right=true; index=1; &#125; for(int i=1;i&lt;n;i++)&#123; if(dominoes[i]=='L' &amp;&amp; !last_is_right)&#123; for(int j=index;j&lt;i;j++)&#123; ans[j]='L'; &#125; index=i+1; last_is_right=false; &#125;//如果当前位置是L且左边没有R，那么将左侧推成L else if(dominoes[i]=='L' &amp;&amp; last_is_right)&#123; for(int j=index;j&lt;(i-index)/2+index;j++)&#123; ans[j]='R'; &#125; for(int j=(i-index)/2+index+(i-index)%2;j&lt;i;j++)&#123; ans[j]='L'; &#125; index=i+1; last_is_right=false; &#125;//如果当前位置是L且上一个位置是R，那么按照奇偶来推，要处理的多米诺骨牌数量是奇数个的话，处理为L的位置要+1 else if(dominoes[i]=='R')&#123; if(last_is_right)&#123; for(int j=index;j&lt;i;j++)&#123; ans[j]='R'; &#125; &#125; last_is_right=true; index=i+1; &#125;//如果当前位置是R，那么看看左边要不要处理为R else&#123; if(i==n-1 &amp;&amp; last_is_right)&#123; for(int j=index;j&lt;n;j++)&#123; ans[j]='R'; &#125; &#125;//末尾的骨牌处理 //否则不做事 &#125; &#125; return ans; &#125; &#125;; &amp;emsp;当然这些代码实际上没什么含金量，但是促使我写这篇博客的直接原因是我看到了这条评论：@太阳家的猫：Py3 class Solution: def pushDominoes(self, dominoes: str) -> str: od = \"\" while dominoes != od: od = dominoes dominoes = dominoes.replace(\"R.L\", \"T\") dominoes = dominoes.replace(\".L\", \"LL\") dominoes = dominoes.replace(\"R.\", \"RR\") dominoes = dominoes.replace(\"T\", \"R.L\") return dominoes &amp;emsp;虽然这还是模拟，时间是O(n^2)，但是这代码实在是太漂亮了，我忍不住把它记录下来，我就是为了这瓶醋才包的这饺子。","categories":[{"name":"力扣做题笔记","slug":"力扣做题笔记","permalink":"https://shinya754.github.io/categories/%E5%8A%9B%E6%89%A3%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://shinya754.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"力扣","slug":"力扣","permalink":"https://shinya754.github.io/tags/%E5%8A%9B%E6%89%A3/"},{"name":"C++","slug":"C","permalink":"https://shinya754.github.io/tags/C/"}]},{"title":"力扣688.骑士在棋盘上的概率","slug":"力扣688-骑士在棋盘上的概率","date":"2022-02-17T11:55:20.000Z","updated":"2022-02-17T12:22:46.120Z","comments":true,"path":"2022/02/17/力扣688-骑士在棋盘上的概率/","link":"","permalink":"https://shinya754.github.io/2022/02/17/%E5%8A%9B%E6%89%A3688-%E9%AA%91%E5%A3%AB%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87/","excerpt":"2022.02.17 688. 骑士在棋盘上的概率https://leetcode-cn.com/problems/knight-probability-in-chessboard/ 在一个 n x n 的国际象棋棋盘上，一个骑士从单元格 (row, column) 开始，并尝试进行 k 次移动。行和列是 从 0 开始 的，所以左上单元格是 (0,0) ，右下单元格是 (n - 1, n - 1) 。 象棋骑士有8种可能的走法，如下图所示。每次移动在基本方向上是两个单元格，然后在正交方向上是一个单元格。 每次骑士要移动时，它都会随机从8种可能的移动中选择一种(即使棋子会离开棋盘)，然后移动到那里。 骑士继续移动，直到它走了 k 步或离开了棋盘。 返回 骑士在棋盘停止移动后仍留在棋盘上的概率 。","text":"2022.02.17 688. 骑士在棋盘上的概率https://leetcode-cn.com/problems/knight-probability-in-chessboard/ 在一个 n x n 的国际象棋棋盘上，一个骑士从单元格 (row, column) 开始，并尝试进行 k 次移动。行和列是 从 0 开始 的，所以左上单元格是 (0,0) ，右下单元格是 (n - 1, n - 1) 。 象棋骑士有8种可能的走法，如下图所示。每次移动在基本方向上是两个单元格，然后在正交方向上是一个单元格。 每次骑士要移动时，它都会随机从8种可能的移动中选择一种(即使棋子会离开棋盘)，然后移动到那里。 骑士继续移动，直到它走了 k 步或离开了棋盘。 返回 骑士在棋盘停止移动后仍留在棋盘上的概率 。 示例 1： 输入: n = 3, k = 2, row = 0, column = 0 输出: 0.0625 解释: 有两步(到(1,2)，(2,1))可以让骑士留在棋盘上。 在每一个位置上，也有两种移动可以让骑士留在棋盘上。 骑士留在棋盘上的总概率是0.0625。 示例 2： 输入: n = 1, k = 0, row = 0, column = 0 输出: 1.00000 提示: 1 &lt;= n &lt;= 25 0 &lt;= k &lt;= 100 0 &lt;= row, column &lt;= n &amp;emsp;学到的知识点：动态规划（这也能动态规划？）&amp;emsp;这时就应该翻出我曾经写下的：如果拿到一个题目我的第一反应是回溯法，那么往往要用动态规划来解决。&amp;emsp;当然我最初的想法是广度优先搜索查找最终停下时可能的位置，但是看看这数据范围，使用这种方法必定超时。&amp;emsp;官方题解给出了一种非常巧妙的思路：使用一个三维数组dp[step][x][y]，其中第一维step代表这是走第step步得到的每个位置的概率（范围是0~k），而后面两维x和y则是在棋盘上的位置，如dp[1][1][4]的元素代表的是走1步能够到达（1，4）这个位置的概率。当step=0时，只有输入的初始位置概率是1，其他位置都为0。&amp;emsp;而动态规划的思想体现在，由于每一个位置都可能由周围的8个位置走一步到达，那么如果求出这8个位置在上一步时的概率，全部加起来除以8即为这个位置在这一步的概率（棋盘外面的概率都视为0，因为不能走出去再走回来）。&amp;emsp;代码：（C++） class Solution &#123; public: double knightProbability(int n, int k, int row, int column) &#123; if(k==0)&#123; return 1.0; &#125; int directions[8][2]=&#123;&#123;-2,-1&#125;,&#123;-1,-2&#125;,&#123;1,-2&#125;,&#123;2,-1&#125;,&#123;2,1&#125;,&#123;1,2&#125;,&#123;-1,2&#125;,&#123;-2,1&#125;&#125;;//初始化方向数组，某个位置加上这8个方向即为这个位置走一步能到的位置 float dp[101][26][26]=&#123;&#123;&#123;0.0&#125;&#125;&#125;;//dp数组的初始化（C++中，不能对动态数组进行初始化，因此使用最原始的超大数组方式） dp[0][row][column]=1; for(int i=1;i&lt;=k;i++)&#123; for(int j=0;j&lt;n;j++)&#123; for(int k=0;k&lt;n;k++)&#123; for(int l=0;l&lt;8;l++)&#123; int x=j+directions[l][0]; int y=k+directions[l][1]; if(x>=0 &amp;&amp; x&lt;=n-1 &amp;&amp; y>=0 &amp;&amp; y&lt;=n-1)&#123; dp[i][j][k]+=dp[i-1][x][y]/8; &#125; &#125; &#125; &#125; &#125;//4层循环，对每一步，每个位置对应的8个方向进行模拟，求出其概率和 double ans=0; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++)&#123; ans+=dp[k][i][j]; &#125; &#125;//把第k步后棋盘上的概率全部加起来得到答案 return ans; &#125; &#125;;","categories":[{"name":"力扣做题笔记","slug":"力扣做题笔记","permalink":"https://shinya754.github.io/categories/%E5%8A%9B%E6%89%A3%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://shinya754.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"力扣","slug":"力扣","permalink":"https://shinya754.github.io/tags/%E5%8A%9B%E6%89%A3/"},{"name":"C++","slug":"C","permalink":"https://shinya754.github.io/tags/C/"},{"name":"动态规划","slug":"动态规划","permalink":"https://shinya754.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"力扣1405.最长快乐字符串","slug":"力扣1405-最长快乐字符串","date":"2022-02-07T14:36:51.000Z","updated":"2022-02-07T14:56:43.780Z","comments":true,"path":"2022/02/07/力扣1405-最长快乐字符串/","link":"","permalink":"https://shinya754.github.io/2022/02/07/%E5%8A%9B%E6%89%A31405-%E6%9C%80%E9%95%BF%E5%BF%AB%E4%B9%90%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"2022.02.07 1405. 最长快乐字符串https://leetcode-cn.com/problems/longest-happy-string/ 如果字符串中不含有任何 &#39;aaa&#39;，&#39;bbb&#39; 或 &#39;ccc&#39; 这样的字符串作为子串，那么该字符串就是一个「快乐字符串」。 给你三个整数 a，b，c，请你返回 任意一个 满足下列全部条件的字符串 s： s 是一个尽可能长的快乐字符串。s 中 最多 有a 个字母 &#39;a&#39;、b 个字母 &#39;b&#39;、c 个字母 &#39;c&#39; 。s 中只含有 &#39;a&#39;、&#39;b&#39; 、&#39;c&#39; 三种字母。如果不存在这样的字符串 s ，请返回一个空字符串 &quot;&quot;。","text":"2022.02.07 1405. 最长快乐字符串https://leetcode-cn.com/problems/longest-happy-string/ 如果字符串中不含有任何 &#39;aaa&#39;，&#39;bbb&#39; 或 &#39;ccc&#39; 这样的字符串作为子串，那么该字符串就是一个「快乐字符串」。 给你三个整数 a，b，c，请你返回 任意一个 满足下列全部条件的字符串 s： s 是一个尽可能长的快乐字符串。s 中 最多 有a 个字母 &#39;a&#39;、b 个字母 &#39;b&#39;、c 个字母 &#39;c&#39; 。s 中只含有 &#39;a&#39;、&#39;b&#39; 、&#39;c&#39; 三种字母。如果不存在这样的字符串 s ，请返回一个空字符串 &quot;&quot;。 示例 1： 输入：a = 1, b = 1, c = 7 输出：\"ccaccbcc\" 解释：\"ccbccacc\" 也是一种正确答案。 示例 2： 输入：a = 2, b = 2, c = 1 输出：\"aabbc\" 示例 3： 输入：a = 7, b = 1, c = 0 输出：\"aabaa\" 解释：这是该测试用例的唯一正确答案。 提示： 0 &lt;= a, b, c &lt;= 100a + b + c &gt; 0 &amp;emsp;学到的知识点：贪心法的应用&amp;emsp;第一眼看到这题，想到的方法是先构造一个字符串，其内容满是a,b,c中最多的那一个，然后用剩下两种字符插入这个字符串，为了实现这个思路，需要分很多种情况（如最初的字符串能&#x2F;不能全部用上等等），太麻烦了，写了一大堆还是有各种遗漏的情况。过程中想到一种与官方题解类似的方法，也是每次取剩余最多的字符，但是根据另外两种字符的数量决定拿一个还是拿两个，但是最后没有去实现这个思路。&amp;emsp;官方的思路是，每次往答案字符串的末尾插入一个剩余最多的字符，如果这个字符不能放，则找第二多的字符，直到至少有两种字符全部用完。&amp;emsp;C++：（和官方的有点不同，主要是退出while循环的条件那里） class Solution &#123; public: string longestDiverseString(int a, int b, int c) &#123; vector&lt;pair&lt;char,int>> vec; vec.push_back(make_pair('a',a)); vec.push_back(make_pair('b',b)); vec.push_back(make_pair('c',c)); sort(vec.begin(),vec.end(),[](pair&lt;char,int> p1,pair&lt;char,int> p2)&#123; return p1.second>=p2.second; &#125;); if(vec[0].second==1 &amp;&amp; vec[1].second==0)&#123; return string(1,vec[0].first); &#125; string ans=\"\"; while(1)&#123; sort(vec.begin(),vec.end(),[](pair&lt;char,int> p1,pair&lt;char,int> p2)&#123; return p1.second>=p2.second; &#125;); for(int i=0;i&lt;3;i++)&#123; int siz=ans.size(); if(vec[i].second&lt;=0)&#123; break; &#125; if(siz>=2 &amp;&amp; ans[siz-2]==vec[i].first &amp;&amp; ans[siz-1]==vec[i].first)&#123; continue; &#125; ans.push_back(vec[i].first); vec[i].second--; break; &#125; int siz=ans.size(); if(siz>=2 &amp;&amp; ans[siz-2]==vec[0].first &amp;&amp; ans[siz-1]==vec[0].first &amp;&amp; vec[1].second&lt;=0)&#123; break; &#125; else if(vec[0].second==0 &amp;&amp; vec[1].second==0 &amp;&amp; vec[2].second==0)&#123; break; &#125; &#125; return ans; &#125; &#125;;","categories":[{"name":"力扣做题笔记","slug":"力扣做题笔记","permalink":"https://shinya754.github.io/categories/%E5%8A%9B%E6%89%A3%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://shinya754.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"力扣","slug":"力扣","permalink":"https://shinya754.github.io/tags/%E5%8A%9B%E6%89%A3/"},{"name":"C++","slug":"C","permalink":"https://shinya754.github.io/tags/C/"},{"name":"贪心法","slug":"贪心法","permalink":"https://shinya754.github.io/tags/%E8%B4%AA%E5%BF%83%E6%B3%95/"}]},{"title":"力扣1996.游戏中弱角色的数量","slug":"力扣1996-游戏中弱角色的数量","date":"2022-01-28T13:14:15.000Z","updated":"2022-01-28T13:39:35.665Z","comments":true,"path":"2022/01/28/力扣1996-游戏中弱角色的数量/","link":"","permalink":"https://shinya754.github.io/2022/01/28/%E5%8A%9B%E6%89%A31996-%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%BC%B1%E8%A7%92%E8%89%B2%E7%9A%84%E6%95%B0%E9%87%8F/","excerpt":"2022.1.28 1996. 游戏中弱角色的数量https://leetcode-cn.com/problems/the-number-of-weak-characters-in-the-game/ 你正在参加一个多角色游戏，每个角色都有两个主要属性：攻击和防御。给你一个二维整数数组properties，其中properties[i] = [attack[i], defense[i]]表示游戏中第i个角色的属性。 如果存在一个其他角色的攻击和防御等级 都严格高于 该角色的攻击和防御等级，则认为该角色为弱角色。更正式地，如果认为角色i弱于存在的另一个角色j，那么attack[j] &gt; attack[i]且defense[j] &gt; defense[i]。 返回弱角色的数量。","text":"2022.1.28 1996. 游戏中弱角色的数量https://leetcode-cn.com/problems/the-number-of-weak-characters-in-the-game/ 你正在参加一个多角色游戏，每个角色都有两个主要属性：攻击和防御。给你一个二维整数数组properties，其中properties[i] = [attack[i], defense[i]]表示游戏中第i个角色的属性。 如果存在一个其他角色的攻击和防御等级 都严格高于 该角色的攻击和防御等级，则认为该角色为弱角色。更正式地，如果认为角色i弱于存在的另一个角色j，那么attack[j] &gt; attack[i]且defense[j] &gt; defense[i]。 返回弱角色的数量。 示例 1： 输入：properties &#x3D; [[5,5],[6,3],[3,6]] 输出：0 解释：不存在攻击和防御都严格高于其他角色的角色。 示例 2： 输入：properties &#x3D; [[2,2],[3,3]] 输出：1 解释：第一个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。 示例 3： 输入：properties &#x3D; [[1,5],[10,4],[4,3]] 输出：1 解释：第三个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。 提示： 2 &lt;&#x3D; properties.length &lt;&#x3D; 105 properties[i].length &#x3D;&#x3D; 2 1 &lt;&#x3D; attack[i], defense[i] &lt;&#x3D; 105 &amp;emsp;太久没做题了思维完全僵化。&amp;emsp;学到的知识点：单调栈，以及C++中的lambda表达式&amp;emsp;虽然想到了要用排序，但是没有想到把攻击力和防御力按照不同顺序排&amp;emsp;大体的思路是，先把攻击力按照降序排列，然后从前往后遍历防御力，如果找到一个角色的防御力小于之前某个角色的防御力，此时如果所有角色的攻击力都不同，那么当前这个角色的攻击力也一定小于那个防御力比他高的角色，那么他是弱角色，因此在遍历过程中需要维护一个int型变量来存储之前的最大防御力值。&amp;emsp;而实际上需要考虑到会有角色攻击力相同的情况，为了避免把某个攻击力等于其他人而防御力低于那个人的角色视为弱角色，可以将攻击力相同的角色内部按照防御力升序排列，这样一来仍然可以进行上一段中所说的查找。&amp;emsp;更加pro的方法是维护一个单调栈，存储角色的防御力，但是单调栈存在更高的空间复杂度。&amp;emsp;排序+遍历： class Solution &#123; public: int numberOfWeakCharacters(vector&lt;vector&lt;int>>&amp; properties) &#123; sort(properties.begin(),properties.end(),[](vector&lt;int>&amp; v1,vector&lt;int>&amp; v2)&#123; if(v1[0]>v2[0])return true; else if(v1[0]==v2[0] &amp;&amp; v1[1]&lt;v2[1])return true; else return false; &#125;); int numOfWeak=0; int maxDef=-1; for(int i=0;i&lt;properties.size();i++)&#123; if(properties[i][1]&lt;maxDef)&#123; numOfWeak++; &#125; if(properties[i][1]>maxDef)&#123; maxDef=properties[i][1]; &#125; &#125; return numOfWeak; &#125; &#125;; &amp;emsp;排序+单调栈： class Solution &#123; public: int numberOfWeakCharacters(vector&lt;vector&lt;int>>&amp; properties) &#123; sort(properties.begin(),properties.end(),[](vector&lt;int>&amp; v1,vector&lt;int>&amp; v2)&#123; if(v1[0]&lt;v2[0])return true; else if(v1[0]==v2[0] &amp;&amp; v1[1]>v2[1])return true; else return false; &#125;); stack&lt;int> sta; int numOfWeak=0; for(int i=0;i&lt;properties.size();i++)&#123; while(!sta.empty() &amp;&amp; sta.top()&lt;properties[i][1])&#123; sta.pop(); numOfWeak++; &#125; sta.push(properties[i][1]); &#125; return numOfWeak; &#125; &#125;; &amp;emsp;在记录一个看到的时间最短的思路，感觉到了智商上的差距。&amp;emsp;思路是维护一个新的vector（数组），以数组的下标作为角色的攻击力，其对应的值作为角色的防御力。","categories":[{"name":"力扣做题笔记","slug":"力扣做题笔记","permalink":"https://shinya754.github.io/categories/%E5%8A%9B%E6%89%A3%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://shinya754.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"力扣","slug":"力扣","permalink":"https://shinya754.github.io/tags/%E5%8A%9B%E6%89%A3/"},{"name":"C++","slug":"C","permalink":"https://shinya754.github.io/tags/C/"},{"name":"lambda表达式","slug":"lambda表达式","permalink":"https://shinya754.github.io/tags/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"参数方程形式的二重积分","slug":"参数方程形式的二重积分","date":"2021-05-30T14:25:27.000Z","updated":"2021-05-30T16:02:31.612Z","comments":true,"path":"2021/05/30/参数方程形式的二重积分/","link":"","permalink":"https://shinya754.github.io/2021/05/30/%E5%8F%82%E6%95%B0%E6%96%B9%E7%A8%8B%E5%BD%A2%E5%BC%8F%E7%9A%84%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86/","excerpt":"一个标题汤家凤1800题第八章入门第16题： 求$\\iint_{D}^{}{y·dxdy}$，其中D是由与x轴围成的区域。","text":"一个标题汤家凤1800题第八章入门第16题： 求$\\iint_{D}^{}{y·dxdy}$，其中D是由与x轴围成的区域。 首先这个L是摆线的图像： 摆线是圆在滚动的过程中，圆周上一点的运动轨迹。 对于这道题，想要求出摆线的直角坐标方程是不现实的，应该使用参数方程求解。 首先按照题中所给的D区域将$\\iint_{D}^{}{y·dxdy}$展开如下： $\\iint_{D}^{}{y·dxdy}$ &#x3D; $\\int_{0}^{2 \\pi a}dx \\int_{0}^{y(x)}y·dy$ 此处，将摆线的直角坐标公式$y&#x3D;y(x)$视作一个待定的x的表达式，第一步对y积分的结果如下： $\\frac{1}{2} \\int_{0}^{2 \\pi a} {y^2(x)}·dx$ 此时，将题中所给的摆线的参数方程带入，得到： $\\frac{1}{2} \\int_{0}^{2 \\pi a} {a^2 (1-cos(t))^2}·dx$ 此外，$dx &#x3D; {a(1-cos(t))}·dt$ 故$\\frac{1}{2} \\int_{0}^{2 \\pi a} {a^2 (1-cos(t))^2}·dx$ &#x3D; $\\frac{1}{2} \\int_{0}^{2 \\pi} {a^3 (1-cos(t))^3}·dt$ 得到最终的结果为$\\frac{5}{2} \\pi a^3$ 学到的知识点：积分区域D以参数方程的形式给出时，可以先将其用待定的$y&#x3D;y(x)$作为积分上下限，最后一步积分时再将其转化为参数方程带入，最后对参数 t 积分即可。 顺便，一个有趣的性质：摆线方程中$\\frac{dx}{dt} &#x3D; y(t)$","categories":[{"name":"高等数学","slug":"高等数学","permalink":"https://shinya754.github.io/categories/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://shinya754.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"高等数学","slug":"高等数学","permalink":"https://shinya754.github.io/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"}]},{"title":"每日lim-5.24","slug":"每日lim-5-24","date":"2021-05-24T12:21:33.000Z","updated":"2021-12-06T11:54:10.182Z","comments":true,"path":"2021/05/24/每日lim-5-24/","link":"","permalink":"https://shinya754.github.io/2021/05/24/%E6%AF%8F%E6%97%A5lim-5-24/","excerpt":"https://t.bilibili.com/528234956842941422?tab=2/计算 $\\lim_{n \\rightarrow \\infty}{(1+sin(\\pi\\sqrt{4n^2+2}))^n}$","text":"https://t.bilibili.com/528234956842941422?tab=2/计算 $\\lim_{n \\rightarrow \\infty}{(1+sin(\\pi\\sqrt{4n^2+2}))^n}$ 正文一眼 $1^\\infty$ 型。先将其按照 $1^\\infty$ 的形式化简： 由于 $\\lim_{n \\rightarrow \\infty}{sin(\\pi\\sqrt{4n^2+2})}&#x3D;0$ ， 原式&#x3D; $ \\lim_{n \\rightarrow \\infty}{(1+sin( \\pi \\sqrt{4n^2+2}))^{\\frac{1}{sin( \\pi \\sqrt{4n^2+2})}n sin( \\pi \\sqrt{4n^2+2})} } $&amp;emsp;&amp;emsp;&#x3D; $e^{\\lim_{n \\rightarrow \\infty}{n sin(\\pi\\sqrt{4n^2+2})} }$ 然后卡在这里了。本来想用洛必达法则计算一下 $\\frac{sin(\\pi\\sqrt{4n^2+2})}{\\frac{1}{n} }$，但是计算结果是 $-\\frac{4 \\pi n^3}{\\sqrt{4n^2+2} }$ 感觉不太对劲，于是去参考大佬的思路学了一手（ 学到的知识点： $sin(x) &#x3D; \\lim_{n \\rightarrow \\infty}{sin(x-2 \\pi n)}$有了这条规律，就可以将 $\\lim_{n \\rightarrow \\infty}{sin(\\pi\\sqrt{4n^2+2})}$ 转化为： $\\lim_{n \\rightarrow \\infty}{sin(\\pi\\sqrt{4n^2+2})}$ &#x3D; $\\lim_{n \\rightarrow \\infty}{sin(\\pi (\\sqrt{4n^2+2}-2n))}$ 而 $\\sqrt{4n^2+2}-2n$ &#x3D; $\\frac{2}{\\sqrt{4n^2+2}+2n}$ （分子有理化） 于是 $\\lim_{n \\rightarrow \\infty}{sin(\\pi\\sqrt{4n^2+2})}$ &#x3D; $\\lim_{n \\rightarrow \\infty}{sin(\\frac{2 \\pi}{\\sqrt{4n^2+2}+2n})}$&amp;emsp;&amp;emsp;&#x3D;$\\lim_{n \\rightarrow \\infty}{\\frac{2 \\pi}{\\sqrt{4n^2+2}+2n} }$ （等价无穷小） 于是 $e^{\\lim_{n \\rightarrow \\infty}{n sin(\\pi\\sqrt{4n^2+2})} }$ &#x3D; $e^{\\lim_{n \\rightarrow \\infty}{\\frac{2 \\pi n}{\\sqrt{4n^2+2}+2n} } }$&amp;emsp;&amp;emsp;&#x3D; $e^{\\lim_{n \\rightarrow \\infty}{\\frac{2 \\pi n}{4n} } }$&amp;emsp;&amp;emsp;&#x3D; $e^{ {\\frac{\\pi}{2} } }$ 顺带一提，石墨文档自带的公式编辑器针不戳啊） 勘误2021.7.8勘误$\\lim_{n \\rightarrow \\infty}{(1+sin(\\pi\\sqrt{4n^2+2}))^n}$中的n是整数所以可以使用$sin(x) &#x3D; \\lim_{n \\rightarrow \\infty}{sin(x-2 \\pi n)}$这一规律 不是，你不说谁知道n是整数啊（恼看了人家的解析还以为学到了新知识点（","categories":[{"name":"每日lim","slug":"每日lim","permalink":"https://shinya754.github.io/categories/%E6%AF%8F%E6%97%A5lim/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://shinya754.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"高等数学","slug":"高等数学","permalink":"https://shinya754.github.io/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"}]},{"title":"力扣421.数组中两个数的最大异或值","slug":"力扣421-数组中两个数的最大异或值","date":"2021-05-16T07:24:43.000Z","updated":"2021-05-16T08:01:06.618Z","comments":true,"path":"2021/05/16/力扣421-数组中两个数的最大异或值/","link":"","permalink":"https://shinya754.github.io/2021/05/16/%E5%8A%9B%E6%89%A3421-%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%80%BC/","excerpt":"2021.5.16 421.数组中两个数的最大异或值https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/给你一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0 ≤ i ≤ j &lt; n 。进阶：你可以在 O(n) 的时间解决这个问题吗？","text":"2021.5.16 421.数组中两个数的最大异或值https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/给你一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0 ≤ i ≤ j &lt; n 。进阶：你可以在 O(n) 的时间解决这个问题吗？ 示例 1： 输入：nums &#x3D; [3,10,5,25,2,8] 输出：28 解释：最大运算结果是 5 XOR 25 &#x3D; 28. 示例 2： 输入：nums &#x3D; [0] 输出：0 示例 3： 输入：nums &#x3D; [2,4] 输出：6 示例 4： 输入：nums &#x3D; [8,10,2] 输出：10 示例 5： 输入：nums &#x3D; [14,70,53,83,49,91,36,80,92,51,66,70] 输出：127 提示： 1 &lt;= nums.length &lt;= 2 * 10^40 &lt;= nums[i] &lt;= 2^31 - 1 &amp;emsp;学到的知识点：字典树的实际应用&amp;emsp;真就异或周了（&amp;emsp;这题最容易想到的方法当然是二重循环遍历了，但是O($n^2$)的时间复杂度没法通过所有的用例。&amp;emsp;虽然不看答案我也想不到字典树能这么用，但还是记录一下思考过程：&amp;emsp;首先题目要求的是取两个数得到最大异或值，异或运算是按位异或，所以能得到的最理想状况，就是先找到数组中二进制最高位的位置最大的那个数，然后这个数有一些位可能是0，那么就在数组中找一个能够把这些0补上的一个比较小的数。&amp;emsp;当然，根据上面的分析会容易想当然地认为，我们要找到最大的那个数，然后再找一个比较小的数，就能得到答案，但是看示例4：[8,10,2]，即[1000,1010,0010]，如果我们先拿出10这个数，那么能得到的最大异或值是10⊕2&#x3D;8，但是实际上8⊕2&#x3D;10，比8要大，所以这个二进制最高位的位置最大的那个数可能并不是数组中最大的那个数，那么要如何找到这个比较大的数就是个麻烦的问题了。 &amp;emsp;看了官方题解之后发现，这道题的重点在于，我们需要从高位向低位判断最终答案的每一二进制位能否取到1。&amp;emsp;结合题目中给的提示，将时间复杂度限制在O(n)以内，联想到力扣第一题使用哈希表的做法，可以想到，应该是要使用某种数据结构，将查找过的数据存起来，然后在低于O(n)的时间内进行一次查找。&amp;emsp;官方题解的方法一，使用哈希表的做法比较难以理解，但是方法二使用字典树的做法还是很好懂的。力扣第一题能够将时间复杂度压缩到O(n)的关键就在于，对于数组中每个数，在哈希表中查找合适的答案的时间复杂度为O(1)，而在字典树中查找一个元素的时间复杂度为O(C)，其中C为字符串的最大长度。此处由于所有数据都是32位有符号整型数字，所以C为31。此外，由于此处将数据视作二进制字符串存入字典树，而二进制数每一位只有0和1两种取值，所以整个字典树实际上是一颗二叉树，并且所有叶子结点都在同一层。&amp;emsp;代码实现：（C#） class Trie&#123; public Trie left=null;//左子树作为选择1的路径 public Trie right=null;//0 &#125; public class Solution &#123; int maxBit=30; Trie root=new Trie(); public int FindMaximumXOR(int[] nums) &#123; if(nums.Length==1)return 0; int ans=0; Add(nums[0]); for(int i=1;i&lt;nums.Length;i++)&#123; ans=Math.Max(ans,Check(nums[i])); Add(nums[i]); &#125; return ans; &#125; ///向字典树中添加一条数据 public void Add(int num)&#123; Trie temp=root; for(int i=maxBit;i>=0;i--)&#123; if(((num>>i)&amp;1)==1)&#123; if(temp.left==null) temp.left=new Trie(); temp=temp.left; &#125; else&#123; if(temp.right==null) temp.right=new Trie(); temp=temp.right; &#125; &#125; &#125; ///在字典树中查找最合适的一个数据，返回得到的异或结果 public int Check(int num)&#123; int x=0; Trie temp=root; for(int i=maxBit;i>=0;i--)&#123; if(((num>>i)&amp;1)==1)&#123;//进行查找的原数字这一位为1，则优先找字典树中这一位为0的数字 if(temp.right!=null)&#123; temp=temp.right; x=x*2+1; &#125; else&#123; temp=temp.left; x=x*2; &#125; &#125; else&#123; if(temp.left!=null)&#123; temp=temp.left; x=x*2+1; &#125; else&#123; temp=temp.right; x=x*2; &#125; &#125; &#125; return x; &#125; &#125;","categories":[{"name":"力扣做题笔记","slug":"力扣做题笔记","permalink":"https://shinya754.github.io/categories/%E5%8A%9B%E6%89%A3%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://shinya754.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"力扣","slug":"力扣","permalink":"https://shinya754.github.io/tags/%E5%8A%9B%E6%89%A3/"},{"name":"树","slug":"树","permalink":"https://shinya754.github.io/tags/%E6%A0%91/"}]},{"title":"洗牌算法","slug":"洗牌算法","date":"2021-05-13T14:29:45.000Z","updated":"2021-09-15T07:24:15.915Z","comments":true,"path":"2021/05/13/洗牌算法/","link":"","permalink":"https://shinya754.github.io/2021/05/13/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/","excerpt":"突然发现我的知识盲区好像有点大这里记录三种常用的洗牌算法。","text":"突然发现我的知识盲区好像有点大这里记录三种常用的洗牌算法。 Fisher-Yates洗牌算法&amp;emsp;核心思想是创建一个新数组，每次从原数组中选一个之前没有选过的元素加入到新数组的末尾。&amp;emsp;一眼就能看懂的东西就直接上代码了：（C#） public List&lt;int> Fisher_Yates_Shuffle(List&lt;int> originList) &#123; List&lt;int> returnList = new List&lt;int>();//创建一个新数组用于存储打乱后的数据 var rand = new Random();//通过Random类的实例获取随机数 while (originList.Count > 0) &#123; int randNum = rand.Next(0, originList.Count);//Random.Next()方法,在左闭右开区间内生成随机整数。 int numToAdd = originList[randNum]; originList.RemoveAt(randNum); returnList.Add(numToAdd); &#125; return returnList; &#125; 代码也是一眼就能看懂。&amp;emsp;由于使用数组（List底层是数组）实现，所以总体时间复杂度是O(n2)，而由于使用了一个最大长度与原来数组相等的数组，所以空间复杂度是O(n)。 &amp;emsp;对原数组中每一个元素都能等概率地出现在新数组中每一个位置的证明：&amp;emsp;元素m被放置在i位置的概率，即为元素m没有被放置在前i-1个位置的概率乘以放置元素在第i个位置时选中元素m的概率。&amp;emsp;元素m不被放置在第一个位置的概率为 $\\frac{n-1}{n}$（最初共有n个元素，除了元素m之外还有n-1个元素。），不被放置在第2个位置的概率为$\\frac{n-2}{n-1}$，以此类推，不被放置在第i-1个位置的概率为$\\frac{n-(i-1)}{n-(i-1)+1}$，被放置在第i个位置的概率为$\\frac{1}{n-(i-1)}$（选中元素m前已经选走了i-1个元素，还剩n-(i-1)个元素），将这些概率相乘则得到元素m被放置在位置i的概率为$\\frac{1}{n}$。&amp;emsp;手写笔记：（字比较丑，图一乐） Knuth-Durstenfeld洗牌算法&amp;emsp;Fisher-Yates算法使用了额外空间来存储打乱后的数组，导致算法的空间复杂度为O(n)，而Knuth-Durstenfeld算法原地修改输入数组，将空间复杂度降低到了O(1)。&amp;emsp;核心思想是将数组划分为有序区和打乱区两个部分（为了描述方便，我们暂且认为打乱前的数组是有序的），有序区在打乱区的前面。在数组被打乱之前，整个数组都是有序区。每次，在有序区中随机选择一个元素，将其与有序区的末尾元素交换，直到整个数组都是打乱区。&amp;emsp;代码如下：（C#） public int[] Knuth_Durstenfeld_Shuffle(int[] originNums) &#123; var rand = new Random(); for (int i = originNums.Length - 1; i >= 0; i--) &#123; int randNum = rand.Next(0, i + 1); //交换这两个数 int temp = originNums[randNum]; originNums[randNum] = originNums[i]; originNums[i] = temp; &#125; return originNums; &#125; &amp;emsp;我最初实现这个算法的时候犯蠢了，因为最近力扣搁那整异或周，导致我在交换两个数的时候用了a^=b;b^=a;a^=b的方法，但是这里randNum是可以等于i的（否则原来的最后一个数必定不在最后），结果就成了a^=a;a^=a;a^=a，然后结果就变成了0。&amp;emsp;这个算法除了改进了Fisher-Yates算法的空间复杂度，还顺便把时间复杂度也给改进了，因为这个算法中不再进行数组的插入和删除。时间复杂度为O(n)。 &amp;emsp;对原数组中每一个元素都能等概率地出现在新数组中每一个位置的证明：&amp;emsp;先上图方便说明，假设数组长度为n：&amp;emsp;首先对于元素4，出现在每一个位置的概率都是$\\frac{1}{n}$，这很容易理解；&amp;emsp;然后对于元素3，出现在位置4（即数组末尾的那个位置）的概率即为元素4选中元素3的概率$\\frac{1}{n}$，而出现在位置3以及之前的概率为元素4没有选中元素3的概率乘以$\\frac{n-2}{n-1}$（元素3以及之前元素的长度为n-1），也是$\\frac{1}{n}$；&amp;emsp;然后对于元素2，出现在位置4的概率为$\\frac{1}{n}$，出现在位置3的概率为元素4没有选到元素2的概率乘以元素3选到元素2的概率，即$\\frac{n-1}{n}$*$\\frac{1}{n-1}$&#x3D;$\\frac{1}{n}$，出现在位置2以及之前的概率同样为$\\frac{1}{n}$，其他元素以此类推。实际上虽然实现略有不同，但是证明思路以及写出来的计算式和Fisher-Yates算法是完全一致的。（毕竟是它的改进版本） Inside-Out洗牌算法&amp;emsp;前两种洗牌算法都有一个共性，就是会改变输入的数组（当然Knuth-Durstenfeld算法可以在方法内复制一个数组从而避免对输入数组的修改，但是人家核心思想就是原地修改…），在有些情况下，我们需要保留输入的数组，使用Inside-Out洗牌算法可以解决这个问题。&amp;emsp;核心思想是先创建一个原数组的复制（毕竟要保留原数组），然后使用类似Knuth-Durstenfeld算法的思路，将数组的前面部分视为打乱区，后面没有处理过的部分视为有序区，每次将有序区的第一个元素与打乱区的随机一个元素交换，然后打乱区大小+1，实现上其实就是Knuth-Durstenfeld算法的反向版本，但是由于Inside-Out算法从前往后扫描数组，所以如果数组以数据流的形式传入，或者无法读取数组长度时，只能使用这种算法，而前两种算法无法使用。&amp;emsp;代码如下：(C#) public int[] Inside_Out_Shuffle(int[] originNums) &#123; int[] resultArr = new int[originNums.Length]; Array.Copy(originNums, resultArr, originNums.Length); var rand = new Random(); for(int i = 0; i &lt; originNums.Length; i++) &#123; int randNum = rand.Next(0, i + 1); resultArr[i] = resultArr[randNum]; resultArr[randNum] = originNums[i];//扩展打乱区后，将刚加入打乱区的数和打乱区内的随机一个数交换。 //借用原数组i位置的元素就不需要使用临时变量来处理数字交换了（ &#125; return resultArr; &#125; &amp;emsp;时间复杂度为O(n)，空间复杂度为O(n)。&amp;emsp;证明和Knuth-Durstenfeld算法完全一致。&amp;emsp;笔记图一乐。 不知道名字的算法&amp;emsp;当年写俄罗斯方块7Bag的时候在网上学了这个算法： private List&lt;T> RandomSort&lt;T>(List&lt;T> list) &#123;//这会返回一个顺序被打乱的List且不改变传入的list var newList = new List&lt;T>(); foreach (var item in list) &#123; newList.Insert(Random.Range(0,newList.Count+1), item); &#125; return newList; &#125; &amp;emsp;代码非常简洁，而且思路也很简单，就是对原数组中的每一个元素，依次将其随机插入新数组中，就像是从牌堆里按顺序抓牌，但是随机地插入手上的牌中。&amp;emsp;由于出现了数组的插入，时间复杂度是O($n^2$)，使用了额外空间以保证不改动原数组，空间复杂度为O(n)。&amp;emsp;证明似乎相当麻烦，不过我们可以很简单地证明原位置为0和n-1的元素出现在位置0和n-1的概率都是$\\frac{1}{n}$。&amp;emsp;不过我猜这个算法应该也是满足每一个元素出现在每一个位置的概率相等的。 思路参考：https://blog.csdn.net/qq_26399665/article/details/79831490","categories":[{"name":"算法","slug":"算法","permalink":"https://shinya754.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://shinya754.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"算法","permalink":"https://shinya754.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"英 汉 词 典（迫真","slug":"英-汉-词-典（迫真","date":"2021-05-07T01:52:35.000Z","updated":"2021-09-02T08:54:14.689Z","comments":true,"path":"2021/05/07/英-汉-词-典（迫真/","link":"","permalink":"https://shinya754.github.io/2021/05/07/%E8%8B%B1-%E6%B1%89-%E8%AF%8D-%E5%85%B8%EF%BC%88%E8%BF%AB%E7%9C%9F/","excerpt":"就 懂得都懂的一篇博客你可少用点拼音吧 词汇递归：recursion(n.)，recursive(adj.)，[rɪˈkɜːrsɪv]遍历：traverse(v.)，[ˈtrævɜːrs; trəˈvɜːrs]","text":"就 懂得都懂的一篇博客你可少用点拼音吧 词汇递归：recursion(n.)，recursive(adj.)，[rɪˈkɜːrsɪv]遍历：traverse(v.)，[ˈtrævɜːrs; trəˈvɜːrs] （不是，你这词汇和例句能不能配合好一点啊 先序：Pre-Order中序：In-Order后序：Post-Order 洗牌：shuffle(v.)，[ˈʃʌfl]。此外，shuffle作为动词时还有拖着脚走、坐立不安、搪塞等意思；作为名词时还有拖着脚走、随机播放装置等意思。 容量：capacity(n.)，[kəˈpæsəti]。还有 能力、地位、生产力 的意思。 部分的：fractional(adj.)，[ˈfrækʃənl]。特指微小的部分。还有 很小的、很少的 的意思。背包：knapsack(n.)，[ˈnæpsæk]。部分背包问题：fractional knapsack problem 调度：schedule(v.)，[ˈskedʒuːl]。此外，schedule作为动词时还有 安排、拉清单 的意思；作为名词时还有 计划（表）、时间表、附件（尤指表格、单据等） 邻接：adjacency(n.)，[əˈdʒeɪsənsi]（d不发音）。特指计算机领域的邻接。邻接矩阵：adjacency matrix 嵌套：nested(adj.)。此外，如果将其视为nest的过去式，则有 筑巢，巢居 的意思。 注释：annotate(v.)，注释;给…作注解(或评注)。它的名词形式是annotation。 utility：实用，实用程序，效用(n.)；多用途的，多功能的(adj.) fragile：脆弱的（特指经济、生态环境等）、易碎的(adj.) attribute [əˈtrɪbjuːt]：属性，特质（n.）；把…归因于（vt.）（attribute…to） “因为、由于”的几种表达1.because of&amp;emsp;较多情况下用于表示导致坏结果的原因，接名词2.due to&amp;emsp;用于表示导致坏结果的原因，可翻译为“归咎于”3.on account of&amp;emsp;非常客观地表示原因，适用于任何情况4.thanks to&amp;emsp;用于表示导致好结果的原因，可翻译为“多亏了” “归因于”的几种表达1.attribute to&amp;emsp;把某事归因于某人（某事），认为某作品出自某人之手，认为某事（物）属于某人（物）。2.owe to&amp;emsp;应该感谢某人，把…归功于 dispatch：派遣，调度，转发，迅速处理，杀死（v.）；派遣，急件，（外地的记者发给报纸的）报道（n.）dispatcher：调度员，转发器（调度程序），分配器（n.） deprecate [ˈdeprəkeɪt]：反对，轻视，声明不赞成（v.）deprecated：不赞成（被使用的方法或者数据结构，如Java中的Stack）","categories":[{"name":"英汉词典","slug":"英汉词典","permalink":"https://shinya754.github.io/categories/%E8%8B%B1%E6%B1%89%E8%AF%8D%E5%85%B8/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://shinya754.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"英语","slug":"英语","permalink":"https://shinya754.github.io/tags/%E8%8B%B1%E8%AF%AD/"}]},{"title":"二叉树的遍历","slug":"二叉树的遍历","date":"2021-04-19T14:06:57.000Z","updated":"2021-06-01T04:06:51.400Z","comments":true,"path":"2021/04/19/二叉树的遍历/","link":"","permalink":"https://shinya754.github.io/2021/04/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/","excerpt":"2021.4.19 二叉树的遍历&amp;emsp;为什么要写这篇博客呢？因为我不会写迭代（&amp;emsp;递归的写法有手就行，这里记录遍历二叉树的两种方法：迭代法和Morris法","text":"2021.4.19 二叉树的遍历&amp;emsp;为什么要写这篇博客呢？因为我不会写迭代（&amp;emsp;递归的写法有手就行，这里记录遍历二叉树的两种方法：迭代法和Morris法 二叉树的迭代遍历&amp;emsp;递归本质上也是使用了堆栈（方法调用存储在栈区），而迭代则是显式地维护了一个栈。 &amp;emsp;先序遍历伪代码：根→左→右 栈S; p &#x3D; root; while(p不为null || S不空)&#123; while(p不为null)&#123; 访问p节点； p的右子树入S; p &#x3D; p的左子树; &#125; p &#x3D; S栈顶弹出; &#125; 毕竟访问完根节点就是左子树，所以根节点和左子节点就不入栈了，而栈中存储的右子节点则表示了每次左子树访问完成后要跳转到的节点。 &amp;emsp;中序遍历伪代码：左→根→右 栈S; p &#x3D; root; while(p || S不空)&#123; while(p)&#123; p入S; p &#x3D; p的左子树; &#125; p &#x3D; S.top 出栈; 访问p; p &#x3D; p的右子树; &#125; 每次p为null时，就找到栈顶所指的节点，因为这时栈顶节点的左子树已经访问完成了，下一个将要访问的节点就是栈顶。我写的： class Solution &#123; public List&lt;Integer> inorderTraversal(TreeNode root) &#123; List&lt;Integer> list = new ArrayList&lt;Integer>(); Deque&lt;TreeNode> stack = new LinkedList&lt;TreeNode>(); while (root != null || !stack.isEmpty()) &#123; while (root != null) &#123; stack.push(root); root = root.left; &#125; root = stack.pop(); list.add(root.val); root = root.right; &#125; return list; &#125; &#125; 好吧，其实和官方题解没区别。 &amp;emsp;后序遍历伪代码：左→右→根&amp;emsp;方法1：先序遍历的逆序 栈S; p&#x3D; root; while(p || S不空)&#123; while(p)&#123; 访问p节点； p的左子树入S; p &#x3D; p的右子树; &#125; p &#x3D; S栈顶弹出; &#125; 结果序列逆序; 万一面试的时候碰到了这题还不让用这种方法，那就方法二&amp;emsp;方法二：使用访问标记&amp;emsp;由于对每个节点，是先访问它的左子树，再访问它的右子树，再访问它本身，但是存在一个问题：一个节点的左右子树访问完后都会返回到这个节点（栈顶为这个节点），需要在第二次返回这个节点时再访问它，可以设置一个bool型的标记，默认为false，第一次访问后将其置为true，第二次访问时发现它是true，然后才访问它。 伪代码： 栈S; p&#x3D; root; T&lt;节点,bool&gt; : 节点标记; while(p || S不空)&#123; while(p)&#123; p入S; p &#x3D; p的左子树; &#125; while(S不空 且 T[S.top] &#x3D; True)&#123; 访问S.top; S.top出S; &#125; if(S不空)&#123; p &#x3D; S.top 的右子树; T[S.top] &#x3D; True; &#125; &#125; 没找到java里怎么用栈存键值对，那就来个官方的阳间版本： public static List&lt;Integer> PostOrder(TreeNode root) &#123; List&lt;Integer> list = new ArrayList&lt;>(); Deque&lt;TreeNode> sta = new LinkedList&lt;>(); TreeNode pre = null;//pre用于指示上一次访问的节点，和上面的访问标记异曲同工 while (root != null || !sta.isEmpty()) &#123; //惯例把左节点存一串进去 while (root != null) &#123; sta.push(root); root = root.left; &#125; //先把栈顶拿出来 root = sta.pop(); //不存在右子树，或右子树已经访问过了 if (root.right == null || root.right == pre) &#123; list.add(root.val); pre = root; root = null; &#125; //右子树存在且没有访问过 else &#123; sta.push(root);//栈顶放回去，下次再访问 root = root.right; &#125; &#125; return list; &#125; &amp;emsp;总结：三种遍历都是维护了一个栈，栈中存储的节点是没有访问到的节点，且栈顶元素总为接下来要访问到的节点：先序遍历一上来就把根和左访问完了，所以栈中存储的是接下来要访问的右子节点；中序遍历先访问最左边的节点，所以栈中存储作为根节点的节点，栈顶的节点被访问并出栈后，指针转移到接下来要访问的右子树，这个右子树访问完后就是下一个栈顶元素；而后序遍历先左再右，栈中存储左右子树访问结束后的根节点。 Morris法&amp;emsp;不论是使用递归还是迭代，空间复杂度都是O(n)，因为都用到了栈，而这个栈最多会存储n个节点（当树是一条链的时候）。为了降低空间复杂度，可以使用Morris法对树进行遍历。 有一种巧妙的方法可以在线性时间内，只占用常数空间来实现前序遍历。这种方法由 J. H. Morris 在 1979 年的论文「Traversing Binary Trees Simply and Cheaply」中首次提出，因此被称为 Morris 遍历。 &amp;emsp;Morris法的整体思路是，对于某个节点左子树的最右叶子结点（即某个节点在中序遍历下的前驱节点），将其right设置为这个某个节点，从而利用了树中的空闲指针。&amp;emsp;通过这种方式，在第一次访问节点时建立连接，第二次访问节点时就可以通过这些连接获得访问节点的次序，从而不再需要维护一个栈，将空间复杂度降低到了O(1)。&amp;emsp;建立连接的过程如下： TreeNode p1=root,p2=null;//p1记录当前在处理的子树的根节点，p2记录这个根节点的左子节点 while (p1!=null)&#123; p2=p1.left; if(p2!=null)&#123; //每次找到当前节点的左子树的最右叶子结点 while (p2.right!=null &amp;&amp; p2.right!=p1)&#123; p2=p2.right; &#125; //如果是第一次访问到这个前驱节点，则建立连接 if(p2.right==null)&#123; p2.right=p1; //先序遍历访问节点 p1=p1.left; //continue &#125; //如果是第二次访问到这个节点，则断开连接，保持树的结构 else if(p2.right==p1)&#123; //中序遍历访问节点 p1=p1.right; p2.right=null; &#125; &#125; //某个子树没有左节点，则访问它的右节点 else &#123; //先序遍历访问节点 //中序遍历访问节点 p1=p1.right; &#125; &#125; &amp;emsp;实际上理解了之后还挺简单的（先序和中序限定） 先序遍历： public List&lt;Integer> PreOrderMorris(TreeNode root) &#123; List&lt;Integer> list = new ArrayList&lt;Integer>(); TreeNode p1=root,p2=null; while (p1!=null)&#123; p2=p1.left; if(p2!=null)&#123; while (p2.right!=null &amp;&amp; p2.right!=p1)&#123; p2=p2.right; &#125; if(p2.right==null)&#123; p2.right=p1; list.add(p1.val);//先序遍历访问节点：第一次遇到节点 p1=p1.left; //continue; &#125; else if(p2.right==p1)&#123; p2.right=null; p1=p1.right; &#125; &#125; else &#123; list.add(p1.val);//先序遍历访问节点：遇到了最左节点 p1=p1.right; &#125; &#125; return list; &#125; 中序遍历： public static List&lt;Integer> MidOrderMorris(TreeNode root)&#123; List&lt;Integer> list = new ArrayList&lt;Integer>(); TreeNode p1=root,p2=null; while (p1!=null)&#123; p2=p1.left; if(p2!=null)&#123; while (p2.right!=null &amp;&amp; p2.right!=p1)&#123; p2=p2.right; &#125; if(p2.right==null)&#123; p2.right=p1; p1=p1.left; //continue &#125; else if(p2.right==p1)&#123; list.add(p1.val);//中序遍历访问节点 //断开连接时说明这个节点的左子树已经访问完了，所以对于中序遍历而言需要访问该节点 p1=p1.right; p2.right=null; &#125; &#125; else &#123; list.add(p1.val);//中序遍历访问节点 p1=p1.right; &#125; &#125; return list; &#125; 后序遍历： 思路借鉴：@jasonhttps://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/die-dai-fa-by-jason-2/ @一个Go语言全干工程师https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/leetcodesuan-fa-xiu-lian-dong-hua-yan-shi-xbian-2/","categories":[{"name":"算法","slug":"算法","permalink":"https://shinya754.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://shinya754.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"数据结构","slug":"数据结构","permalink":"https://shinya754.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","permalink":"https://shinya754.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"前缀树Trie","slug":"前缀树Trie","date":"2021-04-14T12:38:18.000Z","updated":"2021-06-01T04:06:09.063Z","comments":true,"path":"2021/04/14/前缀树Trie/","link":"","permalink":"https://shinya754.github.io/2021/04/14/%E5%89%8D%E7%BC%80%E6%A0%91Trie/","excerpt":"力扣开始教面试题了（bushi 前缀树 &amp;emsp;又叫字典树，单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。","text":"力扣开始教面试题了（bushi 前缀树 &amp;emsp;又叫字典树，单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。 前缀树的性质： 它有3个基本性质：&amp;emsp;根节点不包含字符，除根节点外每一个节点都只包含一个字符； 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串； 每个节点的所有子节点包含的字符都不相同。 &amp;emsp;既然是单词查找树，那树中存储的内容大概是只有字母了，那么复杂度最低的方法就是使用一个Trie[26] children来存储数据，并用一个bool isEnd来表示这个节点能不能作为结束节点。&amp;emsp;当然我看到力扣上这一题的第一反应是用一个Dictionary&lt;char,Trie&gt; dic来存储这个节点的所有子节点，并使用（0,null）这个键值对作为结束节点的标记，但是这样做比数组还慢（&amp;emsp;先是自己用字典实现的前缀树（看起来还是挺简单的）： public class Trie &#123; //用一个字典存储这个节点的所有直接子节点 Dictionary&lt;char,Trie> dic; //构造函数，用于初始化前缀树 public Trie() &#123; dic = new Dictionary&lt;char,Trie>(); &#125; //向前缀树中插入一个单词 public void Insert(string word) &#123; if(word.Length==0)&#123; //结束标记 if(!dic.ContainsKey('0')) dic.Add('0',null); return; &#125; if(!dic.ContainsKey(word[0]))&#123; dic.Add(word[0],new Trie()); &#125; //递归，彳亍！ dic[word[0]].Insert(word.Substring(1)); &#125; //查找某个单词是否在树中，要注意能否找到结束标记 public bool Search(string word) &#123; if(word.Length==0)&#123; if(dic.ContainsKey('0')) return true; else return false; &#125; else&#123; if(!dic.ContainsKey(word[0])) return false; else return dic[word[0]].Search(word.Substring(1)); &#125; &#125; //查找树中是否有某个前缀，无需考虑是否有结束标记 public bool StartsWith(string prefix) &#123; if(prefix.Length==0) return true; if(!dic.ContainsKey(prefix[0])) return false; else return dic[prefix[0]].StartsWith(prefix.Substring(1)); &#125; &#125; &amp;emsp;官方提供的使用数组的版本：（java） class Trie &#123; //children[0]代表'a',children[1]代表'b'…… private Trie[] children; private boolean isEnd; public Trie() &#123; children = new Trie[26]; isEnd = false; &#125; public void insert(String word) &#123; Trie node = this; for (int i = 0; i &lt; word.length(); i++) &#123; //不用分割字符串还是快一些 char ch = word.charAt(i); int index = ch - 'a'; if (node.children[index] == null) &#123; node.children[index] = new Trie(); &#125; node = node.children[index]; &#125; node.isEnd = true; &#125; public boolean search(String word) &#123; Trie node = searchPrefix(word); return node != null &amp;&amp; node.isEnd; &#125; public boolean startsWith(String prefix) &#123; return searchPrefix(prefix) != null; &#125; private Trie searchPrefix(String prefix) &#123; Trie node = this; for (int i = 0; i &lt; prefix.length(); i++) &#123; char ch = prefix.charAt(i); int index = ch - 'a'; if (node.children[index] == null) &#123; return null; &#125; node = node.children[index]; &#125; return node; &#125; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://shinya754.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://shinya754.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"数据结构","slug":"数据结构","permalink":"https://shinya754.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树","slug":"树","permalink":"https://shinya754.github.io/tags/%E6%A0%91/"}]},{"title":"力扣264. 丑数II","slug":"力扣264-丑数II","date":"2021-04-11T12:55:21.000Z","updated":"2021-05-16T03:28:05.610Z","comments":true,"path":"2021/04/11/力扣264-丑数II/","link":"","permalink":"https://shinya754.github.io/2021/04/11/%E5%8A%9B%E6%89%A3264-%E4%B8%91%E6%95%B0II/","excerpt":"2021.4.11 264. 丑数IIhttps://leetcode-cn.com/problems/ugly-number-ii/给你一个整数 n ，请你找出并返回第 n 个 丑数 。丑数 就是只包含质因数 2、3 和&#x2F;或 5 的正整数。","text":"2021.4.11 264. 丑数IIhttps://leetcode-cn.com/problems/ugly-number-ii/给你一个整数 n ，请你找出并返回第 n 个 丑数 。丑数 就是只包含质因数 2、3 和&#x2F;或 5 的正整数。 示例 1： 输入：n &#x3D; 10 输出：12 解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。 示例 2： 输入：n &#x3D; 1 输出：1 解释：1 通常被视为丑数。 提示：1 &lt;= n &lt;= 1690 学到的知识点：动态规划明天写，或者后天我写的：（C#） public class Solution &#123; public int NthUglyNumber(int n) &#123; int index = 0; int max2 = Int32.MaxValue / 2; int max3 = Int32.MaxValue / 3; int max5 = Int32.MaxValue / 5; SortedList sortedList = new SortedList(); sortedList.Add(1, 0); while (index &lt; n + 1) &#123; int i = (int)sortedList.GetKey(index); if (!sortedList.ContainsKey(i * 2) &amp;&amp; i &lt; max2) sortedList.Add(i * 2, 0); if (!sortedList.ContainsKey(i * 3) &amp;&amp; i &lt; max3) sortedList.Add(i * 3, 0); if (!sortedList.ContainsKey(i * 5) &amp;&amp; i &lt; max5) sortedList.Add(i * 5, 0); index++; &#125; return (int)sortedList.GetKey(index - 2); &#125; &#125; 运行时间击败了10%，针不戳你可少玩点SortedList吧学来的： public class Solution &#123; public int NthUglyNumber(int n) &#123; int[] dp = new int[n]; int p2 = 0, p3 = 0, p5 = 0; dp[0] = 1; for (int i = 1; i &lt; n; i++) &#123; dp[i] = Math.Min(Math.Min(dp[p2] * 2, dp[p3] * 3), dp[p5] * 5); if (dp[i] == dp[p2] * 2) p2++; if (dp[i] == dp[p3] * 3) p3++; if (dp[i] == dp[p5] * 5) p5++; &#125; return dp[n - 1]; &#125; &#125; 真优雅。","categories":[{"name":"力扣做题笔记","slug":"力扣做题笔记","permalink":"https://shinya754.github.io/categories/%E5%8A%9B%E6%89%A3%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://shinya754.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"力扣","slug":"力扣","permalink":"https://shinya754.github.io/tags/%E5%8A%9B%E6%89%A3/"}]},{"title":"力扣154. 寻找旋转排序数组中的最小值II","slug":"力扣154-寻找旋转排序数组中的最小值II","date":"2021-04-09T13:35:14.000Z","updated":"2021-05-24T12:22:07.859Z","comments":true,"path":"2021/04/09/力扣154-寻找旋转排序数组中的最小值II/","link":"","permalink":"https://shinya754.github.io/2021/04/09/%E5%8A%9B%E6%89%A3154-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BCII/","excerpt":"2021.4.9 154. 寻找旋转排序数组中的最小值IIhttps://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums &#x3D; [0,1,4,4,5,6,7] 在变化后可能得到：若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。 给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。","text":"2021.4.9 154. 寻找旋转排序数组中的最小值IIhttps://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums &#x3D; [0,1,4,4,5,6,7] 在变化后可能得到：若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。 给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。 示例 1： 输入：nums &#x3D; [1,3,5] 输出：1 示例 2： 输入：nums &#x3D; [2,2,2,0,1] 输出：0 提示： n &#x3D;&#x3D; nums.length1 &lt;&#x3D; n &lt;&#x3D; 5000-5000 &lt;&#x3D; nums[i] &lt;&#x3D; 5000nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转 进阶： 这道题是 寻找旋转排序数组中的最小值 的延伸题目。允许重复会影响算法的时间复杂度吗？会如何影响，为什么？ 学到的知识点：emmm还是二分查找本来是想博客上还是写点有价值的东西，别什么力扣题都网上扔的，但是一看这题困难，还是给个面子吧（我写的hape代码：（C#） public class Solution &#123; public int FindMin(int[] nums) &#123; int left=0; int right=nums.Length-1; while(left&lt;=right)&#123; int middle = (left+right)/2; if(nums[middle]&lt;nums[(middle-1+nums.Length)%nums.Length])&#123; return nums[middle]; &#125; else if(nums[left] &lt; nums[(left - 1 + nums.Length) % nums.Length]) &#123; return nums[left]; &#125; else if (nums[right] &lt; nums[(right - 1 + nums.Length) % nums.Length]) &#123; return nums[right]; &#125; //因为最小值可能有多个，所以左中右都判断一下（ if(nums[middle] == nums[left] &amp;&amp; nums[middle] == nums[right])&#123; left++; //只加left而不减right是为了防止在left=right-1时直接退出循环 continue; &#125; if(middle==left || nums[middle]>=nums[left] &amp;&amp; nums[right]&lt;=nums[left])&#123;//最小值在右边 left=middle+1; &#125; else&#123; right=middle-1; &#125; &#125; //意☆义☆不☆明的nums[0] return nums[0]; &#125; &#125; 学来的优雅代码：（C#） public class Solution &#123; public int FindMin(int[] nums) &#123; int left=0; int right=nums.Length-1; while(left&lt;right)&#123; int middle = (left+right)/2; if(nums[middle]>nums[right])&#123; //最小值在右边 left=middle+1; &#125; else if(nums[middle]&lt;nums[right])&#123; //最小值在左边，或middle处 right=middle; &#125; else&#123; right--; &#125; &#125; return nums[left]; &#125; &#125; 实际上只要比较nums[middle]和nums[right]就可以判断最小值在哪边了，这和二分查找不同。","categories":[{"name":"力扣做题笔记","slug":"力扣做题笔记","permalink":"https://shinya754.github.io/categories/%E5%8A%9B%E6%89%A3%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://shinya754.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"力扣","slug":"力扣","permalink":"https://shinya754.github.io/tags/%E5%8A%9B%E6%89%A3/"}]},{"title":"力扣153. 寻找旋转排序数组中的最小值","slug":"力扣153-寻找旋转排序数组中的最小值","date":"2021-04-08T15:11:39.000Z","updated":"2021-06-01T04:05:35.683Z","comments":true,"path":"2021/04/08/力扣153-寻找旋转排序数组中的最小值/","link":"","permalink":"https://shinya754.github.io/2021/04/08/%E5%8A%9B%E6%89%A3153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/","excerpt":"2021.4.8 153. 寻找旋转排序数组中的最小值https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：&amp;emsp;若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]&amp;emsp;若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。 给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。","text":"2021.4.8 153. 寻找旋转排序数组中的最小值https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：&amp;emsp;若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]&amp;emsp;若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。 给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。 示例 1： 输入：nums &#x3D; [3,4,5,1,2] 输出：1 解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。 示例 2： 输入：nums &#x3D; [4,5,6,7,0,1,2] 输出：0 解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。 示例 3： 输入：nums &#x3D; [11,13,15,17] 输出：11 解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。 提示： n == nums.length1 &lt;= n &lt;= 5000-5000 &lt;= nums[i] &lt;= 5000nums 中的所有整数 互不相同nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转 学到的知识点：二分查找昨天学的东西今天巩固一下还整的挺好。最终代码：（C#） public class Solution &#123; public int FindMin(int[] nums) &#123; int left=0; int right=nums.Length-1; while(left&lt;=right)&#123; int middle = (left+right)/2; //某个数小于它前一个数，说明这个数就是最小的数了 if(nums[middle]&lt;nums[(middle-1+nums.Length)%nums.Length])&#123; return nums[middle]; &#125; //middle==left：左边找完了 //nums[middle]>nums[left]：中位数在左边 //nums[right]&lt;nums[left]：数组移动次数大于0 if(middle==left || nums[middle]>nums[left] &amp;&amp; nums[right]&lt;nums[left])&#123;//最小值在右边 left=middle+1; &#125; else&#123; right=middle-1; &#125; &#125; //这一句是凑数的 return nums[0]; &#125; &#125; 顺便记录一下C#中用于解决此问题的库函数： using System.Linq; public class Solution &#123; public int FindMin(int[] nums) &#123; //返回数组中最小的那个数 return nums.Min(); //nums.Max(); 最大值 //nums.Average(); 平均值 &#125; &#125; （不是，怎么直接遍历一遍比二分法还快的啊（恼","categories":[{"name":"力扣做题笔记","slug":"力扣做题笔记","permalink":"https://shinya754.github.io/categories/%E5%8A%9B%E6%89%A3%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://shinya754.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"力扣","slug":"力扣","permalink":"https://shinya754.github.io/tags/%E5%8A%9B%E6%89%A3/"}]},{"title":"除以2和右移1位的区别","slug":"除以2和右移1位的区别","date":"2021-04-07T15:14:37.000Z","updated":"2021-06-01T04:02:29.555Z","comments":true,"path":"2021/04/07/除以2和右移1位的区别/","link":"","permalink":"https://shinya754.github.io/2021/04/07/%E9%99%A4%E4%BB%A52%E5%92%8C%E5%8F%B3%E7%A7%BB1%E4%BD%8D%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"“&#x2F;2”和”&gt;&gt;1”的区别&amp;emsp;写优先级队列的时候发现，-1/2的值为0，当时是在一个循环中将一个值/2再-1，然后循环执行，结果进入死循环了。&amp;emsp;改成&gt;&gt;1后，不再死循环，原因是-1 &gt;&gt; 1 = -1。&amp;emsp;于是百度了一下两者的区别，找到了这个：","text":"“&#x2F;2”和”&gt;&gt;1”的区别&amp;emsp;写优先级队列的时候发现，-1/2的值为0，当时是在一个循环中将一个值/2再-1，然后循环执行，结果进入死循环了。&amp;emsp;改成&gt;&gt;1后，不再死循环，原因是-1 &gt;&gt; 1 = -1。&amp;emsp;于是百度了一下两者的区别，找到了这个： &amp;emsp;编译器不会将“&#x2F;2”优化为“&gt;&gt;1”，因为当被除数为负数时，&#x2F;2会向上取整，&gt;&gt;1会向下取整。&amp;emsp;即：“&#x2F;2“为“向零取整”，“&gt;&gt;1”永远向下取整。&amp;emsp;由于两个操作效果有差异，当被除数为变量时编译器不知道它是不是负数，无法将两个操作等效，不敢优化。&amp;emsp;要是被除数是常量的话，编译器可以直接在编译期算完结果，不在运行期算，这时候效率是一样的，因为都不用计算（也许，万一编译器不优化咱也没处说理啊）。 &amp;emsp;于是简单研究了一下二者的原理： int a = -5; Console.WriteLine(a / 2); Console.WriteLine(a >> 1); 得到的结果是-2和-3&amp;emsp;除法不知道具体是怎么实现的，但是右移这个操作还是可以合理推断一下的。&amp;emsp;已知在计算机中，数字由补码的形式存储，那么-5这个数在存储时就应该是1011（简便起见使用4位二进制来表示数字，其中第一位是符号位）&amp;emsp;而将-5右移一位后，最低位数字被舍弃，最高位补上符号位，其结果为1101，转化为十进制就是-3。&amp;emsp;/2这个操作只能靠猜了。从前面百度的结果来看，一个数/2后总会向0取整，那么/2可能是先做一次右移操作（通过计组的学习可以知道计算机中的乘除法都是通过移位操作来实现的，这样可以加快运行速度），当结果为负数且小数部分不为0时，舍弃小数部分后+1以实现向0取整。","categories":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://shinya754.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://shinya754.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"计组","slug":"计组","permalink":"https://shinya754.github.io/tags/%E8%AE%A1%E7%BB%84/"}]},{"title":"力扣81. 搜索旋转排序数组II","slug":"力扣81-搜索旋转排序数组II","date":"2021-04-07T14:43:44.000Z","updated":"2021-06-01T04:05:23.896Z","comments":true,"path":"2021/04/07/力扣81-搜索旋转排序数组II/","link":"","permalink":"https://shinya754.github.io/2021/04/07/%E5%8A%9B%E6%89%A381-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84II/","excerpt":"2021.4.7 81. 搜索旋转排序数组IIhttps://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/81. 搜索旋转排序数组 II已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。 在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。 给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。","text":"2021.4.7 81. 搜索旋转排序数组IIhttps://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/81. 搜索旋转排序数组 II已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。 在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。 给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。 示例 1： 输入：nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 0 输出：true 示例 2： 输入：nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 3 输出：false 提示： 1 &lt;= nums.length &lt;= 5000-10^4 &lt;= nums[i] &lt;= 10^4题目数据保证 nums 在预先未知的某个下标上进行了旋转-10^4 &lt;= target &lt;= 10^4 进阶： 这是 搜索旋转排序数组 的延伸题目，本题中的 nums 可能包含重复元素。这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？ 学到的知识点：二分查找&amp;emsp;怎么旋转了也能二分查找啊（&amp;emsp;要用到旋转后的数组部分有序的特性&amp;emsp;没做过前面那题，不进阶了（自己写的：（C#） public class Solution &#123; public bool Search(int[] nums, int target) &#123; if(nums[0]>target)&#123; for(int i=nums.Length-1;i>=0;i--)&#123; if(nums[i]==target)&#123; return true; &#125; &#125; return false; &#125; else&#123; for(int i=0;i&lt;nums.Length;i++)&#123; if(nums[i]==target)&#123; return true; &#125; &#125; return false; &#125; &#125; &#125; &amp;emsp;思路是不管数组怎么旋转，第一个数应该是中间的某个数，除非不旋转（&amp;emsp;那么如果要找的数比这第一个数小就从后往前找，否则从前往后找&amp;emsp;时间复杂度是O(n)，其中n为数组长度从官方题解学的：（C#） public class Solution &#123; public bool Search(int[] nums, int target) &#123; if(nums.Length==0)&#123; return false; &#125; if(nums.Length==1)&#123; return nums[0]==target; &#125;//边界条件 int left=0,right=nums.Length-1; while(left&lt;=right)&#123; int middle = (left+right)/2;//还是二分查找 if(nums[middle]==target)&#123; return true; &#125; //查找的数组可能出现left==middle==right的情况，此时无法判断左边和右边哪个有序，只能缩小查找范围 if(nums[left]==nums[middle] &amp;&amp; nums[middle]==nums[right])&#123; left++; right--; &#125; //最左边的数比中间的数小，则旋转处的下标小于middle（旋转了不到一半） else if(nums[left]&lt;=nums[middle])&#123; //在确定了旋转不到一半的情况下，左边的数组是部分有序的部分，猜测target在左边 if(nums[left]&lt;=target &amp;&amp; target&lt;nums[middle])&#123;//要包含等于 right=middle-1; &#125; else&#123; left=middle+1; &#125; &#125; //最左边的数比中间的数大，则旋转处的下标大于middle（旋转了超过一半） else&#123; //在确定了旋转了超过一半的情况下，右边的数组是有序的部分，猜测target在右边 if(nums[middle]&lt;target &amp;&amp; nums[right]>=target)&#123; left=middle+1; &#125; else&#123; right=middle-1; &#125; &#125; &#125; return false; &#125; &#125; &amp;emsp;时间复杂度是O(lg n)","categories":[{"name":"力扣做题笔记","slug":"力扣做题笔记","permalink":"https://shinya754.github.io/categories/%E5%8A%9B%E6%89%A3%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://shinya754.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"力扣","slug":"力扣","permalink":"https://shinya754.github.io/tags/%E5%8A%9B%E6%89%A3/"}]},{"title":"力扣88. 合并两个有序数组","slug":"力扣88-合并两个有序数组","date":"2021-04-05T14:02:20.000Z","updated":"2021-06-01T04:01:26.801Z","comments":true,"path":"2021/04/05/力扣88-合并两个有序数组/","link":"","permalink":"https://shinya754.github.io/2021/04/05/%E5%8A%9B%E6%89%A388-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/","excerpt":"2021.4.5 88. 合并两个有序数组https://leetcode-cn.com/problems/merge-sorted-array/给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。","text":"2021.4.5 88. 合并两个有序数组https://leetcode-cn.com/problems/merge-sorted-array/给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。 示例 1： 输入：nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3, nums2 &#x3D; [2,5,6], n &#x3D; 3 输出：[1,2,2,3,5,6] 示例 2： 输入：nums1 &#x3D; [1], m &#x3D; 1, nums2 &#x3D; [], n &#x3D; 0 输出：[1] 提示： &amp;emsp;nums1.length == m + n&amp;emsp;nums2.length == n&amp;emsp;0 &lt;= m, n &lt;= 200&amp;emsp;1 &lt;= m + n &lt;= 200&amp;emsp;-10^9 &lt;= nums1[i], nums2[i] &lt;= 10^9 学到的知识点：双指针&amp;emsp;看到题：合并起来然后排序（&amp;emsp;但是这样做的话时间复杂度是O(m*lg m)，而且完全没有利用到两个数组的有序性&amp;emsp;那么可以借用一下归并排序的思路，从大到小维护两个指针（实际上是两个Index），然后将两数组中的数字从大到小写入nums1中即可。&amp;emsp;最终代码1（合并后排序）：（C#） public class Solution &#123; public void Merge(int[] nums1, int m, int[] nums2, int n) &#123; for(int i=m;i&lt;m+n;i++)&#123; nums1[i]=nums2[i-m]; &#125; Array.Sort(nums1); &#125; &#125; &amp;emsp;真短。&amp;emsp;最终代码2（双指针）：（C#） public class Solution &#123; public void Merge(int[] nums1, int m, int[] nums2, int n) &#123; int i=m-1;//用i指示nums1中的数字 int j=n-1;//用j指示nums2中的数字 int index=m+n-1;//用index指示nums1中已经写入数字的位置 while(i>=0 &amp;&amp; j>=0)&#123; //将nums1和nums2中最大的数比较，然后将较大的写入nums1的index处 if(nums1[i]>=nums2[j])&#123; nums1[index--] = nums1[i--]; &#125; else&#123; nums1[index--] = nums2[j--]; &#125; &#125; //如果数字还有剩下的，那么他们一定比已经写入的数字都小，则直接将其写入nums1前面没有进行写入的位置 while(i>=0)&#123; nums1[index--] = nums1[i--]; &#125; while(j>=0)&#123; nums1[index--] = nums2[j--]; &#125; &#125; &#125;","categories":[{"name":"力扣做题笔记","slug":"力扣做题笔记","permalink":"https://shinya754.github.io/categories/%E5%8A%9B%E6%89%A3%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://shinya754.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"力扣","slug":"力扣","permalink":"https://shinya754.github.io/tags/%E5%8A%9B%E6%89%A3/"}]},{"title":"力扣42. 接雨水","slug":"力扣42-接雨水","date":"2021-04-02T13:50:18.000Z","updated":"2021-06-01T03:57:35.331Z","comments":true,"path":"2021/04/02/力扣42-接雨水/","link":"","permalink":"https://shinya754.github.io/2021/04/02/%E5%8A%9B%E6%89%A342-%E6%8E%A5%E9%9B%A8%E6%B0%B4/","excerpt":"2021.4.2 面试题 17.21. 直方图的水量（42. 接雨水）https://leetcode-cn.com/problems/volume-of-histogram-lcci/ 给定一个直方图(也称柱状图)，假设有人从上面源源不断地倒水，最后直方图能存多少水量?直方图的宽度为 1。上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的直方图，在这种情况下，可以接 6 个单位的水（蓝色部分表示水）。 感谢 Marcos 贡献此图。","text":"2021.4.2 面试题 17.21. 直方图的水量（42. 接雨水）https://leetcode-cn.com/problems/volume-of-histogram-lcci/ 给定一个直方图(也称柱状图)，假设有人从上面源源不断地倒水，最后直方图能存多少水量?直方图的宽度为 1。上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的直方图，在这种情况下，可以接 6 个单位的水（蓝色部分表示水）。 感谢 Marcos 贡献此图。 示例: 输入: [0,1,0,2,1,0,1,3,2,1,2,1] 输出: 6 学到的知识点：单调栈、动态规划、双指针&amp;emsp;一看到这张刻在DNA里的图，我立马就想起了当年大二被一个高二的ACM选手教育啥是单调栈这件事（&amp;emsp;然后拿单调栈写出来了，发现还有两种方法：动态规划和双指针官方题解最终代码：（单调栈实现） public class Solution &#123; public int Trap(int[] height) &#123; int answer = 0; Stack&lt;int> sta = new Stack&lt;int>();//单调递增栈，从栈底到栈顶单调递减 for (int i = 0; i &lt; height.Length; i++) &#123; if (sta.Count == 0 || height[sta.Peek()] >= height[i])//栈为空或遇到小于等于栈顶的元素则入栈 &#123; sta.Push(i); &#125; else &#123; while (sta.Count > 0 &amp;&amp; height[sta.Peek()] &lt; height[i])//遇到大于栈顶的元素则出栈直到可以入栈 &#123; int tempIndex = sta.Pop(); if (sta.Count > 0) &#123; //每次出栈后计算栈顶位置和入栈位置之间可以存的水量 answer += (i - sta.Peek() - 1) * (Math.Min(height[sta.Peek()], height[i]) - height[tempIndex]); &#125; &#125; sta.Push(i); &#125; &#125; return answer; &#125; &#125;","categories":[{"name":"力扣做题笔记","slug":"力扣做题笔记","permalink":"https://shinya754.github.io/categories/%E5%8A%9B%E6%89%A3%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://shinya754.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"力扣","slug":"力扣","permalink":"https://shinya754.github.io/tags/%E5%8A%9B%E6%89%A3/"}]},{"title":"由力扣90.子集II引发的对于C#中的List和C++中的vector区别的思考","slug":"由力扣90-子集II引发的对于C-中的List和C-中的vector区别的思考","date":"2021-04-01T14:12:00.000Z","updated":"2021-06-01T03:57:23.091Z","comments":true,"path":"2021/04/01/由力扣90-子集II引发的对于C-中的List和C-中的vector区别的思考/","link":"","permalink":"https://shinya754.github.io/2021/04/01/%E7%94%B1%E5%8A%9B%E6%89%A390-%E5%AD%90%E9%9B%86II%E5%BC%95%E5%8F%91%E7%9A%84%E5%AF%B9%E4%BA%8EC-%E4%B8%AD%E7%9A%84List%E5%92%8CC-%E4%B8%AD%E7%9A%84vector%E5%8C%BA%E5%88%AB%E7%9A%84%E6%80%9D%E8%80%83/","excerpt":"由力扣90.子集II引发的对于C#中的List和C++中的vector区别的思考引言：解题的思考过程&amp;emsp;昨天的力扣每日一题： 90.子集II&amp;emsp;最初我看到这一题时，想到了在 1178.猜字谜 中学到的位掩码，使用位掩码可以将集合压缩为一个二进制数，从而能够很方便地求出这个集合的子集。&amp;emsp;在对这一题进行编码求解时，我最初使用语言的是C#，力扣提供的C#模板是这样的： public class Solution &#123; public IList&lt;IList&lt;int>> SubsetsWithDup(int[] nums) &#123; &#125; &#125;","text":"由力扣90.子集II引发的对于C#中的List和C++中的vector区别的思考引言：解题的思考过程&amp;emsp;昨天的力扣每日一题： 90.子集II&amp;emsp;最初我看到这一题时，想到了在 1178.猜字谜 中学到的位掩码，使用位掩码可以将集合压缩为一个二进制数，从而能够很方便地求出这个集合的子集。&amp;emsp;在对这一题进行编码求解时，我最初使用语言的是C#，力扣提供的C#模板是这样的： public class Solution &#123; public IList&lt;IList&lt;int>> SubsetsWithDup(int[] nums) &#123; &#125; &#125; 可以看到返回值是IList&lt;IList&lt;int&gt;&gt;类型，也就是说要使用一个List来存储求得的结果，于是按照我的思路，最初的代码写成了下面这样： public static IList&lt;IList&lt;int>> SubsetsWithDup(int[] nums) &#123; IList&lt;IList&lt;int>> ansList = new List&lt;IList&lt;int>>(); int bitMask = (int)Math.Pow(2, nums.Length) - 1; int subset = bitMask; do &#123; IList&lt;int> tempList = new List&lt;int>(); subset = (subset - 1) &amp; bitMask;//其中每一次循环得到的subset就是mask的全部子集，不会重复 for(int i = 0; i &lt; nums.Length; i++) &#123; if (((subset >> i) &amp; 1) == 1) &#123; tempList.Add(nums[i]); &#125; &#125;//得到一个子集 if (!ansList.Contains(tempList))//问题的关键在这一行 &#123; ansList.Add(tempList); &#125;//如果子集不重复，则将其加入ansList &#125; while (subset != bitMask); return ansList; &#125; &amp;emsp;但是在对示例[1,2,2]进行测试时，得到的返回结果是这样的：&amp;emsp;可以看到，重复的列表[2]和[1,2]并没有被检测出来，即使他们与已有的列表中的数据和顺序都完全一致。当时我隐约觉得这可能和List是引用类型有关，从而导致在将两个List进行比较时无法得到我想要的结果。&amp;emsp;于是，为了赶在12点之前写完代码提交，又不想直接抄一份交上去，我选择了换成C++碰碰运气。&amp;emsp;根据以往的经验，力扣的题目在C#的方法返回值是IList时，C++的方法返回值应该是vector。果然，C++的模板如下： class Solution &#123; public: vector&lt;vector&lt;int>> subsetsWithDup(vector&lt;int>&amp; nums) &#123; &#125; &#125;; &amp;emsp;把C#代码对应地改为C++代码如下： class Solution &#123; public: vector&lt;vector&lt;int>> subsetsWithDup(vector&lt;int>&amp; nums) &#123; vector&lt;vector&lt;int>> ansList; int bitMask = (int)pow(2, nums.size()) - 1; int subset = bitMask; do &#123; vector&lt;int> tempList; subset = (subset - 1) &amp; bitMask;//其中每一次循环得到的subset就是mask的全部子集，不会重复 for (int i = 0; i &lt; nums.size(); i++) &#123; if (((subset >> i) &amp; 1) == 1) &#123; tempList.push_back(nums[i]); &#125; &#125; //此处检测Vector中是否存在某元素这一操作使用了（百度随便找的）迭代器 vector&lt;vector&lt;int>>::iterator ret = find(ansList.begin(), ansList.end(), tempList); if (ret == ansList.end()) &#123; ansList.push_back(tempList); &#125; &#125; while (subset != bitMask); return ansList; &#125; &#125;; &amp;emsp;对[1,2,2]这一示例进行测试发现得到的返回结果是正确的，猜对了（&amp;emsp;但是倒在了这个输入前面：&amp;emsp;检查发现应该是对于两个vector，如果其中的数据相同但是顺序不同，会被视作两个不同的vector，于是加入下面的代码来在每次将tempList存入ansList前，对tempList进行排序： sort(tempList.begin(), tempList.end()); &amp;emsp;然后终于通过了，虽然运行时间只击败了6%（&amp;emsp;那么今天就来研究一下为什么C#中的两个List即使包含的数据和顺序在都一致时会被判断为不相等，以及C++中两个vector为什么能被判断为相等。 对C#中的List的思考研究&amp;emsp;根据最初的代码内容，想要找到这个答案就应该从List&lt;T&gt;.Contains()方法入手。&amp;emsp;在查阅了微软的C#文档后，发现其中提到： &amp;emsp;The List class uses both an equality comparer and an ordering comparer.&amp;emsp;Methods such as Contains, IndexOf, LastIndexOf, and Remove use an equality comparer for the list elements. The default equality comparer for type T is determined as follows. If type T implements the IEquatable generic interface, then the equality comparer is the Equals(T) method of that interface; otherwise, the default equality comparer is Object.Equals(Object). &amp;emsp;官方机翻： &amp;emsp;List类使用相等比较器和排序比较器。&amp;emsp;诸如Contains、IndexOf、LastIndexOf 和Remove等方法，对列表元素使用相等比较器。 按如下方式确定类型的默认相等比较器 T 。如果类型 T 实现 IEquatable 泛型接口，则相等比较器是 Equals(T) 该接口的方法; 否则，默认的相等比较器为 Object.Equals(Object)。 &amp;emsp;也就是说List如果继承了IEquatable接口，只要看一下List&lt;T&gt;.Equals(T)是如何实现的就行了。查看List的原码，发现List并没有继承IEquatable接口，也就是说两个List在进行比较时，使用的是Object类的Object.Equals(Object)方法。&amp;emsp;对于这个方法，官方文档的描述是这样的： 如果指定的对象等于当前对象，则为 true；否则为 false。 &amp;emsp;这句说了和没说一样的话并不能解决眼下的问题，不过根据以往的积累，如果进行比较的两个对象是值类型，那么比较的是两个对象的值；如果进行比较的两个对象是引用类型，那么比较的是两个对象的引用（也就是内存空间）。&amp;emsp;List类型当然不是值类型，那么两个List无论如何进行比较，得到的结果都必然是不相等。&amp;emsp;（为了严谨还是测试一下） &amp;emsp;结果是False &amp;emsp;结果是True&amp;emsp;到这里，两个List无法比较的问题已经解决了。 对C++中的vector的思考研究&amp;emsp;根据C++版本的代码中的内容，我们应该看看find()方法的实现。 &amp;emsp;find() 函数本质上是一个模板函数，用于在指定范围内查找和目标元素值相等的第一个元素。&amp;emsp;如下为 find() 函数的语法格式：InputIterator find (InputIterator first, InputIterator last, const T&amp; val);&amp;emsp;其中，first 和 last 为输入迭代器，[first, last) 用于指定该函数的查找范围；val 为要查找的目标元素。&amp;emsp;正因为 first 和 last 的类型为输入迭代器，因此该函数适用于所有的序列式容器。&amp;emsp;另外，该函数会返回一个输入迭代器，当 find() 函数查找成功时，其指向的是在 [first, last) 区域内查找到的第一个目标元素；如果查找失败，则该迭代器的指向和 last 相同。&amp;emsp;值得一提的是，find() 函数的底层实现，其实就是用&#x3D; &#x3D;运算符将 val 和 [first, last) 区域内的元素逐个进行比对。这也就意味着，[first, last) 区域内的元素必须支持&#x3D; &#x3D;运算符。 （不是，两个&#x3D; &#x3D;中间怎么会标黄的啊（&#x3D;&#x3D;这样&#x3D;&#x3D; &amp;emsp;那么来看看vector有没有重载&#x3D; &#x3D;运算符&amp;emsp;根据 这篇博客 ，虽然微软的C++文档中没有写vector重载了&#x3D; &#x3D;运算符，但实际上vector是重载了&#x3D; &#x3D;运算符的。 *虽然卡文上没有写，但是这张怪兽可以特殊召唤（（无端联想 &amp;emsp;两个vector的比较，正如上文中说到的那样，在元素相同且元素排列顺序相同时，返回的结果为1，否则为0。&amp;emsp;测试：&amp;emsp;输出为1&amp;emsp;输出为0的比较懂得都懂，就不放图了。 总结&amp;emsp;C#中的List&lt;T&gt;没有继承IEquatable&lt;T&gt;接口，所以两个List在使用Equals()方法进行比较时，使用的是Object类的Equals()方法，两个没有重载Equals()方法的引用类型的变量在进行比较时，比较的是他们的存储空间，所以得到的结果必然是false。&amp;emsp;而List&lt;T&gt;的Contains()方法是调用Equals()方法进行的比较，所以在对List&lt;List&lt;T&gt;&gt;使用Contains()方法查询一个List&lt;T&gt;是否存在于其中时，得到的结果也必然是false。&amp;emsp;C++中的vector重载了= =运算符，两个vector在使用= =运算符进行比较时，会将其中的元素从头到尾进行比较，即元素和元素的顺序都相同时，得到的结果就是1（true），否则是0（false）。&amp;emsp;在对vector&lt;vector&lt;T&gt;&gt;使用find方法查找其中是否存在某个vector时，find方法是使用= =运算符对每个元素进行比较，所以可以得到正确的结果。 &amp;emsp;顺便扩展一下C++中的begin()和end()方法： &amp;emsp;使用前应该先引入容器头文件和命名空间std。 begin函数：返回指向指定接口参数所访问的集合开头的迭代器。end函数：返回指向集合末尾以外的迭代器，该集合由指定的接口参数访问。 begin(myvector) 等同于执行 myvector.begin()，而 end(myvector) 也等同于执行 myvector.end() 参考资料：List.Contains(T) 方法vector类C++ find()函数用法详解C++ STL begin()和end()函数用法","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://shinya754.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://shinya754.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"C#","slug":"C","permalink":"https://shinya754.github.io/tags/C/"},{"name":"C++","slug":"C","permalink":"https://shinya754.github.io/tags/C/"}]},{"title":"力扣90. 子集II","slug":"力扣90-子集II","date":"2021-03-31T15:41:01.000Z","updated":"2021-06-01T03:56:44.464Z","comments":true,"path":"2021/03/31/力扣90-子集II/","link":"","permalink":"https://shinya754.github.io/2021/03/31/%E5%8A%9B%E6%89%A390-%E5%AD%90%E9%9B%86II/","excerpt":"2021.3.30 90. 子集IIhttps://leetcode-cn.com/problems/subsets-ii/给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。","text":"2021.3.30 90. 子集IIhttps://leetcode-cn.com/problems/subsets-ii/给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。 示例 1： 输入：nums &#x3D; [1,2,2] 输出：[[],[1],[1,2],[1,2,2],[2],[2,2]] 示例 2： 输入：nums &#x3D; [0] 输出：[[],[0]] 提示： 1 &lt;= nums.length &lt;= 10-10 &lt;= nums[i] &lt;= 10 学到的知识点：位掩码（学歪来位掩码，haowan这个方法是在 1178.猜字谜 中学到的，使用一个int型数的每一二进制位代表集合中的一项。使用以下代码可以很方便地循环求出这个位掩码所代表的集合的全部不重复子集： //int mask=原集合状态压缩后的数 //int subset=mask do&#123; subset = (subset - 1) &amp; mask;//其中每一次循环得到的subset就是mask的全部子集，不会重复 &#125;while(subset!=mask); //由于int型数据在存储时使用的是二进制补码，所以当subset==0时，subset-1的结果为二进制的全1 //再与mask做&amp;运算即可得到subset==mask，退出循环。 最终代码（C++）： public: vector&lt;vector&lt;int>> subsetsWithDup(vector&lt;int>&amp; nums) &#123; vector&lt;vector&lt;int>> ansList; //由于要求原集合的子集，所以每一个数都需要用到，故代表原集合的位掩码为全1 int bitMask = (int)pow(2, nums.size()) - 1; int subset = bitMask; do &#123; vector&lt;int> tempList; subset = (subset - 1) &amp; bitMask;//其中每一次循环得到的subset就是mask的全部子集，不会重复 for (int i = 0; i &lt; nums.size(); i++) &#123; if (((subset >> i) &amp; 1) == 1) &#123; tempList.push_back(nums[i]); &#125; &#125;//得到一个子集存储于tempList中 //判断ansList中是否存在与tempList相等的vector，不存在则加入。 sort(tempList.begin(), tempList.end()); vector&lt;vector&lt;int>>::iterator ret = find(ansList.begin(), ansList.end(), tempList); if (ret == ansList.end()) &#123; ansList.push_back(tempList); &#125; &#125; while (subset != bitMask); return ansList; &#125; &#125;;","categories":[{"name":"力扣做题笔记","slug":"力扣做题笔记","permalink":"https://shinya754.github.io/categories/%E5%8A%9B%E6%89%A3%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://shinya754.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"力扣","slug":"力扣","permalink":"https://shinya754.github.io/tags/%E5%8A%9B%E6%89%A3/"}]},{"title":"力扣173. 二叉搜索树迭代器","slug":"力扣173-二叉搜索树迭代器","date":"2021-03-29T02:55:19.000Z","updated":"2021-06-01T03:53:21.375Z","comments":true,"path":"2021/03/29/力扣173-二叉搜索树迭代器/","link":"","permalink":"https://shinya754.github.io/2021/03/29/%E5%8A%9B%E6%89%A3173-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/","excerpt":"2021.3.28 173. 二叉搜索树迭代器https://leetcode-cn.com/problems/binary-search-tree-iterator/实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器：&amp;emsp;BSTIterator(TreeNode root) 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。&amp;emsp;boolean hasNext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。&amp;emsp;int next()将指针向右移动，然后返回指针处的数字。注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次调用将返回 BST 中的最小元素。 你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 的中序遍历中至少存在一个下一个数字。","text":"2021.3.28 173. 二叉搜索树迭代器https://leetcode-cn.com/problems/binary-search-tree-iterator/实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器：&amp;emsp;BSTIterator(TreeNode root) 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。&amp;emsp;boolean hasNext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。&amp;emsp;int next()将指针向右移动，然后返回指针处的数字。注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次调用将返回 BST 中的最小元素。 你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 的中序遍历中至少存在一个下一个数字。 示例： 输入 [&quot;BSTIterator&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;] [[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []] 输出 [null, 3, 7, true, 9, true, 15, true, 20, false] 解释 BSTIterator bSTIterator &#x3D; new BSTIterator([7, 3, 15, null, null, 9, 20]); bSTIterator.next(); &#x2F;&#x2F; 返回 3 bSTIterator.next(); &#x2F;&#x2F; 返回 7 bSTIterator.hasNext(); &#x2F;&#x2F; 返回 True bSTIterator.next(); &#x2F;&#x2F; 返回 9 bSTIterator.hasNext(); &#x2F;&#x2F; 返回 True bSTIterator.next(); &#x2F;&#x2F; 返回 15 bSTIterator.hasNext(); &#x2F;&#x2F; 返回 True bSTIterator.next(); &#x2F;&#x2F; 返回 20 bSTIterator.hasNext(); &#x2F;&#x2F; 返回 False 提示： 树中节点的数目在范围 [1, $10^5$] 内0 &lt;= Node.val &lt;= $10^6$最多调用 105 次 hasNext 和 next 操作 进阶： 你可以设计一个满足下述条件的解决方案吗？next() 和 hasNext() 操作均摊时间复杂度为 O(1) ，并使用 O(h) 内存。其中 h 是树的高度。 学到的知识点：迭代器问就是不会写，只会用个列表把树先遍历存储这个方法是在 341. 扁平化嵌套列表迭代器 中学到的。代码： public class BSTIterator &#123; int index = 0; List&lt;int> list; public BSTIterator(TreeNode root) &#123; list = new List&lt;int>(); ReadTree(root); &#125; public int Next() &#123; return list[index++]; &#125; public bool HasNext() &#123; if(index &lt; list.Count)&#123; return true; &#125; else&#123; return false; &#125; &#125; public void ReadTree(TreeNode node)&#123; if(node.left!=null)&#123; ReadTree(node.left); &#125; list.Add(node.val); if(node.right!=null)&#123; ReadTree(node.right); &#125; &#125; &#125; 迭代器待写","categories":[{"name":"力扣做题笔记","slug":"力扣做题笔记","permalink":"https://shinya754.github.io/categories/%E5%8A%9B%E6%89%A3%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://shinya754.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"力扣","slug":"力扣","permalink":"https://shinya754.github.io/tags/%E5%8A%9B%E6%89%A3/"}]},{"title":"力扣456. 132模式","slug":"力扣456-132模式","date":"2021-03-24T11:44:16.000Z","updated":"2021-06-01T03:51:26.493Z","comments":true,"path":"2021/03/24/力扣456-132模式/","link":"","permalink":"https://shinya754.github.io/2021/03/24/%E5%8A%9B%E6%89%A3456-132%E6%A8%A1%E5%BC%8F/","excerpt":"2021.3.24 456. 132模式https://leetcode-cn.com/problems/132-pattern/ 给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足：i &lt; j &lt; k 和 nums[i] &lt; nums[k] &lt; nums[j] 。 如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。 进阶：很容易想到时间复杂度为 O(n^2) 的解决方案，你可以设计一个时间复杂度为 O(n logn) 或 O(n) 的解决方案吗？","text":"2021.3.24 456. 132模式https://leetcode-cn.com/problems/132-pattern/ 给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足：i &lt; j &lt; k 和 nums[i] &lt; nums[k] &lt; nums[j] 。 如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。 进阶：很容易想到时间复杂度为 O(n^2) 的解决方案，你可以设计一个时间复杂度为 O(n logn) 或 O(n) 的解决方案吗？ 示例 1： 输入：nums &#x3D; [1,2,3,4] 输出：false 解释：序列中不存在 132 模式的子序列。 示例 2： 输入：nums &#x3D; [3,1,4,2] 输出：true 解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。 示例 3： 输入：nums &#x3D; [-1,3,2,0] 输出：true 解释：序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。 学到的知识点：单调栈&amp;emsp;今天这一题我看到题的第一反应是使用一个单调递增栈从前往后地记录数字，这样必定可以记录到能够作为1的数和能够作为3的数，结果在[3,5,0,1,4]这个数列面前倒下了。（然后看了一眼评论区）&amp;emsp;重新思考：作为1的数要是一个相当小的数，作为3的数要是一个尽量大的数，作为2的数要是一个比3小，但是尽量大的数。&amp;emsp;由于本题2在3的右边，所以要找到一个尽量大的2，就需要从右往左进行查找，每当找到3时就更新2的值（使其尽量的大），这个过程可以使用一个单调递减栈完成（对每个2，要找到第一个比他大的数作为3）。如果有过出栈行为，则说明有一组2和3，那么这时只要找到一个比2小的1就可以了。&amp;emsp;所以，在每次找到一个新的3时，将最后一个出栈（尽量大）的数设置为2，往前读到新的数时，如果他比这个2小，那么他就是1。即：单调栈维护的是3，int two维护的是2，枚举的是1。 最终代码如下： public class Solution &#123; public bool Find132pattern(int[] nums) &#123; Stack&lt;int> sta = new Stack&lt;int>(); int two = int.MinValue; for(int i=nums.Length-1;i>=0;i--)&#123; if(nums[i]&lt;two)&#123; return true; &#125; if(sta.Count()==0||nums[i]&lt;sta.Peek())&#123; sta.Push(nums[i]); &#125; else&#123; while(sta.Count()>0&amp;&amp;sta.Peek()&lt;nums[i])&#123; two=sta.Pop(); &#125; sta.Push(nums[i]); &#125; &#125; return false; &#125; &#125;","categories":[{"name":"力扣做题笔记","slug":"力扣做题笔记","permalink":"https://shinya754.github.io/categories/%E5%8A%9B%E6%89%A3%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://shinya754.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"力扣","slug":"力扣","permalink":"https://shinya754.github.io/tags/%E5%8A%9B%E6%89%A3/"}]},{"title":"Markdown基本操作记录","slug":"Markdown基本操作记录","date":"2021-03-24T09:33:24.000Z","updated":"2021-06-01T03:51:01.736Z","comments":true,"path":"2021/03/24/Markdown基本操作记录/","link":"","permalink":"https://shinya754.github.io/2021/03/24/Markdown%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/","excerpt":"1.标题 一级标题二级标题最多六级标题一行文字前面加几个#就是几级标题，#后面要加上空格。 2.引用 引用引用 在一段话前面加上&gt;即可设置引用，结束引用需要额外按一下换行。 *在文章中加上《!–more–》以截断文章","text":"1.标题 一级标题二级标题最多六级标题一行文字前面加几个#就是几级标题，#后面要加上空格。 2.引用 引用引用 在一段话前面加上&gt;即可设置引用，结束引用需要额外按一下换行。 *在文章中加上《!–more–》以截断文章 3.图片与链接博客主页（画师为bison仓鼠，Pixiv71471901）在方括号[ ]中填入描述，然后在紧接着的圆括号( )中填入链接。如果是图片就在方括号前面加一个感叹号’！’。*链接前面需要手动加上https://，否则会进入https://当前URL/括号内的链接/ 4.粗体与斜体这是粗体这是斜体粗体就左右各用两个，斜体就左右各用一个。 5.表格 标题（必须要有标题） 表头1 表头2 表头3 左边是左对齐 中间是居中对齐 右边是右对齐 看来对齐方式影响表头 6.代码块 using System; int main()&#123; Console.WriteLine(\"Hello World!\"); &#125; 这种一大块的，前一行和后一行用三个反引号&#96;包括，前一行的反引号后面可以写代码所使用的语言以实现代码高亮（如csharp,cpp,java,python） 不是，你怎么 不自动换行的啊？这种一行的，前面和后面用一个反引号&#96;包括，其中的换行符会显示为空格 7.分割线 三个或以上的星号*即可 8.上标下标105105在要变成上标的数字两边加上&lt;sup》和《&#x2F;sup&gt;下标就sub 9.分式$\\frac{n-1}{n}$两个$中间夹个\\frac{分子}{分母}就行","categories":[{"name":"其他分类","slug":"其他分类","permalink":"https://shinya754.github.io/categories/%E5%85%B6%E4%BB%96%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://shinya754.github.io/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2021-03-23T09:10:02.000Z","updated":"2022-07-21T04:44:35.512Z","comments":true,"path":"2021/03/23/我的第一篇博客/","link":"","permalink":"https://shinya754.github.io/2021/03/23/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"（那啥我还不会Markdown啊）&amp;emsp;第一篇博客就写一下我创建这个博客时的心情吧 &amp;emsp;创建好这个博客的那一刻，我的脑海中浮现出“这是属于我的地方”这种想法。 &amp;emsp;千言万语汇聚成两个字：好suang &amp;emsp;虽然大三下期才搭建好自己的博客，跟前辈们比起来实在是晚太多了，但是这算是我成为一个合格码农的开始吧（大概 &amp;emsp;这个博客跟着 https://www.bilibili.com/video/BV1Yb411a7ty?t=58 这个长度不超过半小时视频，花了一个下午（包含午觉）的时间就完成了（期间被加载不出图片的gitee折磨了一个小时），感谢UP主的分享。 &amp;emsp;关于博客主题（皮肤），视频中推荐的就是yilia，本来我想用点跟别人不一样的东西，就跑去hexo主题网站找，结果还是被yilia的移动端适配牢牢套住了。 &amp;emsp;不过不得不说的是，GitHub在墙内访问速度属实拉胯，放了个948KB的头像结果能给我加载一分钟，看来要考虑把这个头像清晰度降低一点。 &amp;emsp;虽然这篇文章创建时间是下午5点，但是晚上被今天力扣的每日一题折磨，拖到12点才有时间写下这些内容。本来还打算今天开始把每日一题的笔记写在博客上的，实在惭愧。 &amp;emsp;就这样吧，先睡了，明天整一下头像以及评论系统。","categories":[{"name":"其他分类","slug":"其他分类","permalink":"https://shinya754.github.io/categories/%E5%85%B6%E4%BB%96%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://shinya754.github.io/tags/%E5%85%B6%E4%BB%96/"},{"name":"日记","slug":"日记","permalink":"https://shinya754.github.io/tags/%E6%97%A5%E8%AE%B0/"}]}],"categories":[{"name":"力扣做题笔记","slug":"力扣做题笔记","permalink":"https://shinya754.github.io/categories/%E5%8A%9B%E6%89%A3%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/"},{"name":"深度学习","slug":"深度学习","permalink":"https://shinya754.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"论文总结","slug":"论文总结","permalink":"https://shinya754.github.io/categories/%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/"},{"name":"实用","slug":"实用","permalink":"https://shinya754.github.io/categories/%E5%AE%9E%E7%94%A8/"},{"name":"高等数学","slug":"高等数学","permalink":"https://shinya754.github.io/categories/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"},{"name":"每日lim","slug":"每日lim","permalink":"https://shinya754.github.io/categories/%E6%AF%8F%E6%97%A5lim/"},{"name":"算法","slug":"算法","permalink":"https://shinya754.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"英汉词典","slug":"英汉词典","permalink":"https://shinya754.github.io/categories/%E8%8B%B1%E6%B1%89%E8%AF%8D%E5%85%B8/"},{"name":"数据结构","slug":"数据结构","permalink":"https://shinya754.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://shinya754.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"其他分类","slug":"其他分类","permalink":"https://shinya754.github.io/categories/%E5%85%B6%E4%BB%96%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://shinya754.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"力扣","slug":"力扣","permalink":"https://shinya754.github.io/tags/%E5%8A%9B%E6%89%A3/"},{"name":"动态规划","slug":"动态规划","permalink":"https://shinya754.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"Java","slug":"Java","permalink":"https://shinya754.github.io/tags/Java/"},{"name":"pytorch","slug":"pytorch","permalink":"https://shinya754.github.io/tags/pytorch/"},{"name":"pytorch3d","slug":"pytorch3d","permalink":"https://shinya754.github.io/tags/pytorch3d/"},{"name":"python","slug":"python","permalink":"https://shinya754.github.io/tags/python/"},{"name":"yolov5","slug":"yolov5","permalink":"https://shinya754.github.io/tags/yolov5/"},{"name":"区块链","slug":"区块链","permalink":"https://shinya754.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"智能汽车","slug":"智能汽车","permalink":"https://shinya754.github.io/tags/%E6%99%BA%E8%83%BD%E6%B1%BD%E8%BD%A6/"},{"name":"读论文","slug":"读论文","permalink":"https://shinya754.github.io/tags/%E8%AF%BB%E8%AE%BA%E6%96%87/"},{"name":"Web","slug":"Web","permalink":"https://shinya754.github.io/tags/Web/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://shinya754.github.io/tags/JavaScript/"},{"name":"AJAX","slug":"AJAX","permalink":"https://shinya754.github.io/tags/AJAX/"},{"name":"Python","slug":"Python","permalink":"https://shinya754.github.io/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://shinya754.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"C++","slug":"C","permalink":"https://shinya754.github.io/tags/C/"},{"name":"贪心法","slug":"贪心法","permalink":"https://shinya754.github.io/tags/%E8%B4%AA%E5%BF%83%E6%B3%95/"},{"name":"lambda表达式","slug":"lambda表达式","permalink":"https://shinya754.github.io/tags/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"高等数学","slug":"高等数学","permalink":"https://shinya754.github.io/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"},{"name":"树","slug":"树","permalink":"https://shinya754.github.io/tags/%E6%A0%91/"},{"name":"算法","slug":"算法","permalink":"https://shinya754.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"英语","slug":"英语","permalink":"https://shinya754.github.io/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"数据结构","slug":"数据结构","permalink":"https://shinya754.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","permalink":"https://shinya754.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"计组","slug":"计组","permalink":"https://shinya754.github.io/tags/%E8%AE%A1%E7%BB%84/"},{"name":"C#","slug":"C","permalink":"https://shinya754.github.io/tags/C/"},{"name":"其他","slug":"其他","permalink":"https://shinya754.github.io/tags/%E5%85%B6%E4%BB%96/"},{"name":"日记","slug":"日记","permalink":"https://shinya754.github.io/tags/%E6%97%A5%E8%AE%B0/"}]}